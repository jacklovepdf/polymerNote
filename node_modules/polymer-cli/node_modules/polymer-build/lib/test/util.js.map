{"version":3,"sources":["../src/test/util.ts"],"names":[],"mappings":"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","file":"util.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport File = require('vinyl');\nimport {assert} from 'chai';\n\nexport function getFlowingState(stream: NodeJS.ReadableStream): boolean {\n  // Cast our streams to <any> so that we can check the flowing state.\n  // _readableState is undocumented in the Node.js TypeScript definition,\n  // however it is the supported way to assert if a stream is flowing or not.\n  // See: https://nodejs.org/api/stream.html#stream_three_states\n  // tslint:disable-next-line: no-any\n  const privateReadableState = (<any>stream)._readableState;\n  return privateReadableState.flowing;\n}\n\n/**\n * This method makes it possible to `await` a map of paths to `File` objects\n * emitted by a stream. It returns a Promise that resolves with the map\n * where the paths in the map exclude the optional `root` prefix.\n */\nexport async function emittedFiles(\n    stream: NodeJS.ReadableStream,\n    root: string = ''): Promise<Map<string, File>> {\n  const files = new Map<string, File>();\n  return new Promise<Map<string, File>>(\n      (resolve, reject) =>\n          stream\n              .on('data',\n                  (f: File) => files.set(f.path.substring(root.length + 1), f))\n              .on('data', () => {/* starts the stream */})\n              .on('end', () => resolve(files))\n              .on('error', (e: Error) => reject(e)));\n}\n\n/**\n * Assert that two strings are equal after collapsing their whitespace.\n */\nexport const assertEqualIgnoringWhitespace =\n    (actual: string, expected: string) =>\n        assert.equal(collapseWhitespace(actual), collapseWhitespace(expected));\n\n/**\n * Assert that two string maps are equal, where their values have had their\n * whitespace collapsed.\n */\nexport const assertMapEqualIgnoringWhitespace =\n    (actual: Map<string, string>, expected: Map<string, string>) =>\n        assertMapEqual(\n            transformMapValues(actual, collapseWhitespace),\n            transformMapValues(expected, collapseWhitespace));\n\n/**\n * Collapse all leading whitespace, trailing whitespace, and newlines. Very\n * lossy, but good for loose comparison of HTML, JS, etc.\n */\nconst collapseWhitespace = (s: string) =>\n    s.replace(/^\\s+/gm, '').replace(/\\s+$/gm, '').replace(/\\n/gm, '');\n\n/**\n * Assert that two maps are equal. Note that early versions of chai's deepEqual\n * will always return true, and while later ones will compare correctly, they do\n * not produce very readable output compared to this approach.\n */\nconst assertMapEqual = <K, V>(actual: Map<K, V>, expected: Map<K, V>) =>\n    assert.deepEqual([...actual.entries()], [...expected.entries()]);\n\n/**\n * Return a new map where all values have been transformed with the given\n * function.\n */\nconst transformMapValues =\n    <K, V1, V2>(map: Map<K, V1>, transform: (val: V1) => V2): Map<K, V2> =>\n        new Map([...map.entries()].map(\n            ([key, val]): [K, V2] => [key, transform(val)]));\n\n/**\n * Calls the given async function and captures all console.log and friends\n * output while until the returned Promise settles.\n *\n * Does not capture plylog, which doesn't seem to be very easy to intercept.\n *\n * TODO(rictic): this function is shared across many of our packages,\n *   put it in a shared package instead.\n */\nexport async function interceptOutput(captured: () => Promise<void>):\n    Promise<string> {\n  const originalLog = console.log;\n  const originalError = console.error;\n  const originalWarn = console.warn;\n  const buffer: string[] = [];\n  const capture = (...args: any[]) => {\n    buffer.push(args.join(' '));\n  };\n  console.log = capture;\n  console.error = capture;\n  console.warn = capture;\n  const restoreAndGetOutput = () => {\n    console.log = originalLog;\n    console.error = originalError;\n    console.warn = originalWarn;\n    return buffer.join('\\n');\n  };\n  try {\n    await captured();\n  } catch (err) {\n    const output = restoreAndGetOutput();\n    console.error(output);\n    throw err;\n  }\n\n  return restoreAndGetOutput();\n}\n"]}