{"version":3,"sources":["../src/streams.ts"],"names":[],"mappings":"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","file":"streams.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {fs} from 'mz';\nimport {Deferred} from 'polymer-analyzer/lib/core/utils';\nimport {PassThrough, Transform} from 'stream';\n\nimport File = require('vinyl');\n\nconst multipipe = require('multipipe');\n\nif (Symbol.asyncIterator === undefined) {\n  // tslint:disable-next-line: no-any polyfilling.\n  (Symbol as any).asyncIterator = Symbol('asyncIterator');\n}\n\n/**\n * Waits for the given ReadableStream\n */\nexport function waitFor(stream: NodeJS.ReadableStream):\n    Promise<NodeJS.ReadableStream> {\n  return new Promise<NodeJS.ReadableStream>((resolve, reject) => {\n    stream.on('end', resolve);\n    stream.on('error', reject);\n  });\n}\n\n/**\n * Waits for all the given ReadableStreams\n */\nexport function waitForAll(streams: NodeJS.ReadableStream[]):\n    Promise<NodeJS.ReadableStream[]> {\n  return Promise.all<NodeJS.ReadableStream>(streams.map((s) => waitFor(s)));\n}\n\n/**\n * Returns the string contents of a Vinyl File object, waiting for\n * all chunks if the File is a stream.\n */\nexport async function getFileContents(file: File): Promise<string> {\n  if (file.isBuffer()) {\n    return file.contents.toString('utf-8');\n  } else if (file.isStream()) {\n    const stream = file.contents;\n    stream.setEncoding('utf-8');\n    const contents: string[] = [];\n    stream.on('data', (chunk: string) => contents.push(chunk));\n\n    return new Promise<string>((resolve, reject) => {\n      stream.on('end', () => resolve(contents.join('')));\n      stream.on('error', reject);\n    });\n  }\n  throw new Error(\n      `Unable to get contents of file ${file.path}. ` +\n      `It has neither a buffer nor a stream.`);\n}\n\n/**\n * Composes multiple streams (or Transforms) into one.\n */\nexport function compose(streams: NodeJS.ReadWriteStream[]) {\n  if (streams && streams.length > 0) {\n    return multipipe(streams);\n  } else {\n    return new PassThrough({objectMode: true});\n  }\n}\n\n\n/**\n * An asynchronous queue that is read as an async iterable.\n */\nclass AsyncQueue<V> implements AsyncIterable<V> {\n  private blockedOn: Deferred<IteratorResult<V>>|undefined = undefined;\n  backlog: Array<{value: IteratorResult<V>, deferred: Deferred<void>}> = [];\n  private _closed = false;\n  private _finished = false;\n\n  /**\n   * Add the given value onto the queue.\n   *\n   * The return value of this method resolves once the value has been removed\n   * from the queue. Useful for flow control.\n   *\n   * Must not be called after the queue has been closed.\n   */\n  async write(value: V) {\n    if (this._closed) {\n      throw new Error('Wrote to closed writable iterable');\n    }\n    return this._write({value, done: false});\n  }\n\n  /**\n   * True once the queue has been closed and all input has been read from it.\n   */\n  get finished() {\n    return this._finished;\n  }\n\n  /**\n   * Close the queue, indicating that no more values will be written.\n   *\n   * If this method is not called, a consumer iterating over the values will\n   * wait forever.\n   *\n   * The returned promise resolves once the consumer has been notified of the\n   * end of the queue.\n   */\n  async close() {\n    this._closed = true;\n    return this._write({done: true} as IteratorResult<V>);\n  }\n\n  private async _write(value: IteratorResult<V>) {\n    if (this.blockedOn) {\n      this.blockedOn.resolve(value);\n      this.blockedOn = undefined;\n    } else {\n      const deferred = new Deferred<void>();\n      this.backlog.push({value, deferred});\n      await deferred.promise;\n    }\n  }\n\n  /**\n   * Iterate over values in the queue. Not intended for multiple readers.\n   * In the case where there are multiple readers, some values may be received\n   * by multiple readers, but all values will be seen by at least one reader.\n   */\n  async * [Symbol.asyncIterator](): AsyncIterator<V> {\n    while (true) {\n      let value;\n      const maybeValue = this.backlog.shift();\n      if (maybeValue) {\n        maybeValue.deferred.resolve(undefined);\n        value = maybeValue.value;\n      } else {\n        this.blockedOn = new Deferred();\n        value = await this.blockedOn.promise;\n      }\n      if (value.done) {\n        this._finished = true;\n        this._write(value);\n        return;\n      } else {\n        yield value.value;\n      }\n    }\n  }\n}\n\n/**\n * Implements `stream.Transform` via standard async iteration.\n *\n * The main advantage over implementing stream.Transform itself is that correct\n * error handling is built in and easy to get right, simply by using\n * async/await.\n *\n * `In` and `Out` extend `{}` because they may not be `null`.\n */\nexport abstract class AsyncTransformStream<In extends {}, Out extends {}>\n    extends Transform {\n  private readonly _inputs = new AsyncQueue<In>();\n\n  /**\n   * Implement this method!\n   *\n   * Read from the given iterator to consume input, yield values to write\n   * chunks of your own. You may yield any number of values for each input.\n   *\n   * Note: currently you *must* completely consume `inputs` and return for this\n   *   stream to close.\n   */\n  protected abstract _transformIter(inputs: AsyncIterable<In>):\n      AsyncIterable<Out>;\n\n  private _initialized = false;\n  private _writingFinished = new Deferred<void>();\n  private _initializeOnce() {\n    if (this._initialized === false) {\n      this._initialized = true;\n      const transformDonePromise = (async () => {\n        for await (const value of this._transformIter(this._inputs)) {\n          // TODO(rictic): if `this.push` returns false, should we wait until\n          //     we get a drain event to keep iterating?\n          this.push(value);\n        }\n      })();\n      transformDonePromise.then(() => {\n        if (this._inputs.finished) {\n          this._writingFinished.resolve(undefined);\n        } else {\n          this.emit(\n              'error',\n              new Error(\n                  `${this.constructor.name}` +\n                  ` did not consume all input while transforming.`));\n          // Since _transformIter has exited, but not all input was consumed,\n          // this._flush won't be called. We need to signal manually that\n          // no more output will be written by this stream.\n          this.push(null);\n        }\n      }, (err) => this.emit('error', err));\n    }\n  }\n\n  /**\n   * Don't override.\n   *\n   * Passes input into this._inputs.\n   */\n  _transform(\n      input: In,\n      _encoding: string,\n      callback: (error?: Error, value?: Out) => void) {\n    this._initializeOnce();\n    this._inputs.write(input).then(() => {\n      callback();\n    }, (err) => callback(err));\n  }\n\n\n  /**\n   * Don't override.\n   *\n   * Finish writing out the outputs.\n   */\n  protected async _flush(\n      callback: (err?: null|undefined|string|Partial<Error>) => void) {\n    try {\n      // We won't get any more inputs. Wait for them all to be processed.\n      await this._inputs.close();\n      // Wait for all of our output to be written.\n      await this._writingFinished.promise;\n      callback();\n    } catch (e) {\n      callback(e);\n    }\n  }\n}\n\n/**\n * A stream that takes file path strings, and outputs full Vinyl file objects\n * for the file at each location.\n */\nexport class VinylReaderTransform extends AsyncTransformStream<string, File> {\n  constructor() {\n    super({objectMode: true});\n  }\n\n  protected async *\n      _transformIter(paths: AsyncIterable<string>): AsyncIterable<File> {\n    for await (const filePath of paths) {\n      yield new File({path: filePath, contents: await fs.readFile(filePath)});\n    }\n  }\n}\n\nexport type PipeStream = (NodeJS.ReadableStream|NodeJS.WritableStream|\n                          NodeJS.ReadableStream[]|NodeJS.WritableStream[]);\n\n/**\n * pipeStreams() takes in a collection streams and pipes them together,\n * returning the last stream in the pipeline. Each element in the `streams`\n * array must be either a stream, or an array of streams (see PipeStream).\n * pipeStreams() will then flatten this array before piping them all together.\n */\nexport function pipeStreams(streams: PipeStream[]): NodeJS.ReadableStream {\n  return Array.prototype.concat.apply([], streams)\n      .reduce((a: NodeJS.ReadableStream, b: NodeJS.ReadWriteStream) => {\n        return a.pipe(b);\n      });\n}\n"]}