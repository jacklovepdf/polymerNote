{"version":3,"sources":["../src/babel-plugin-bare-specifiers.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;AAEH,sFAAsE;AAGtE,mGAA+E;AAE/E,MAAM,eAAe,GAAG,CAAC,CAAS,EAAE,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAK5D;;GAEG;AACU,QAAA,qBAAqB,GAAG,CACjC,QAAgB,EAChB,kBAA2B,EAC3B,WAAoB,EACpB,YAAqB,EACrB,OAAgB,EACd,EAAE,CAAC,CAAC;IACR,QAAQ,EAAE,sCAAmB;IAE7B,OAAO,EAAE;QACP,cAAc,CAAC,IAA8B;YAC3C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,IAAI,IAAI,CAAC,MAAM,CAAC,IAAc,KAAK,QAAQ,EAAE;gBAC3C,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBACvC,IAAI,YAAY,CAAC,IAAI,KAAK,eAAe,EAAE;oBACzC,sBAAsB;oBACtB,OAAO;iBACR;gBACD,MAAM,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC;gBACrC,YAAY,CAAC,KAAK,GAAG,YAAY,CAC7B,SAAS,EACT,QAAQ,EACR,kBAAkB,EAClB,WAAW,EACX,YAAY,EACZ,OAAO,CAAC,CAAC;aACd;QACH,CAAC;QACD,+DAA+D,CAC3D,IAA4B;YAC9B,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YAEvB,oCAAoC;YACpC,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,EAAE;gBACvB,OAAO;aACR;YAED,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;YACpC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,YAAY,CAC5B,SAAS,EACT,QAAQ,EACR,kBAAkB,EAClB,WAAW,EACX,YAAY,EACZ,OAAO,CAAC,CAAC;QACf,CAAC;KACF;CACF,CAAC,CAAC;AAEH,MAAM,YAAY,GAAG,CACjB,SAAiB,EACjB,QAAgB,EAChB,kBAA2B,EAC3B,WAAoB,EACpB,YAAqB,EACrB,OAAgB,EACd,EAAE;IACN,IAAI;QACF,IAAI,aAAa,CAAC;QAClB,IAAI,kBAAkB,EAAE;YACtB,aAAa,GAAG;gBACd,WAAW,EAAE,WAAY;gBACzB,YAAY,EAAE,YAAa;gBAC3B,OAAO,EAAE,OAAQ;aAClB,CAAC;SACH;QACD,OAAO,gCAAO,CAAC,SAAS,EAAE,QAAQ,EAAE,aAAa,CAAC,CAAC;KACpD;IAAC,OAAO,CAAC,EAAE;QACV,qEAAqE;QACrE,2CAA2C;QAC3C,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,IAAI,SAAS,KAAK,SAAS;YACtD,SAAS,KAAK,MAAM,EAAE;YACxB,oEAAoE;YACpE,iEAAiE;YACjE,OAAO;YACP,OAAO,CAAC,IAAI,CACR,uCAAuC,SAAS,IAAI;gBACpD,YAAY,QAAQ,IAAI,CAAC,CAAC;SAC/B;QACD,OAAO,SAAS,CAAC;KAClB;AACH,CAAC,CAAC","file":"babel-plugin-bare-specifiers.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport dynamicImportSyntax from '@babel/plugin-syntax-dynamic-import';\nimport {NodePath} from '@babel/traverse';\nimport {CallExpression, ExportAllDeclaration, ExportNamedDeclaration, ImportDeclaration} from 'babel-types';\nimport {resolve} from 'polymer-analyzer/lib/javascript/resolve-specifier-node';\n\nconst isPathSpecifier = (s: string) => /^\\.{0,2}\\//.test(s);\n\ntype HasSpecifier =\n    ImportDeclaration|ExportNamedDeclaration|ExportAllDeclaration;\n\n/**\n * Rewrites so-called \"bare module specifiers\" to be web-compatible paths.\n */\nexport const resolveBareSpecifiers = (\n    filePath: string,\n    isComponentRequest: boolean,\n    packageName?: string,\n    componentDir?: string,\n    rootDir?: string,\n    ) => ({\n  inherits: dynamicImportSyntax,\n\n  visitor: {\n    CallExpression(path: NodePath<CallExpression>) {\n      const node = path.node;\n      if (node.callee.type as string === 'Import') {\n        const specifierArg = node.arguments[0];\n        if (specifierArg.type !== 'StringLiteral') {\n          // Should never happen\n          return;\n        }\n        const specifier = specifierArg.value;\n        specifierArg.value = maybeResolve(\n            specifier,\n            filePath,\n            isComponentRequest,\n            packageName,\n            componentDir,\n            rootDir);\n      }\n    },\n    'ImportDeclaration|ExportNamedDeclaration|ExportAllDeclaration'(\n        path: NodePath<HasSpecifier>) {\n      const node = path.node;\n\n      // An export without a 'from' clause\n      if (node.source == null) {\n        return;\n      }\n\n      const specifier = node.source.value;\n      node.source.value = maybeResolve(\n          specifier,\n          filePath,\n          isComponentRequest,\n          packageName,\n          componentDir,\n          rootDir);\n    }\n  }\n});\n\nconst maybeResolve = (\n    specifier: string,\n    filePath: string,\n    isComponentRequest: boolean,\n    packageName?: string,\n    componentDir?: string,\n    rootDir?: string,\n    ) => {\n  try {\n    let componentInfo;\n    if (isComponentRequest) {\n      componentInfo = {\n        packageName: packageName!,\n        componentDir: componentDir!,\n        rootDir: rootDir!,\n      };\n    }\n    return resolve(specifier, filePath, componentInfo);\n  } catch (e) {\n    // `require` and `meta` are fake imports that our other build tooling\n    // injects, so we should not warn for them.\n    if (!isPathSpecifier(specifier) && specifier !== 'require' &&\n        specifier !== 'meta') {\n      // Don't warn if the specifier was already a path, even though we do\n      // resolve paths, because maybe the user is serving it some other\n      // way.\n      console.warn(\n          `Could not resolve module specifier \"${specifier}\" ` +\n          `in file \"${filePath}\".`);\n    }\n    return specifier;\n  }\n};\n"]}