{"version":3,"sources":["../src/push-manifest.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,6BAA6B;AAC7B,uDAAmF;AACnF,+DAA8D;AAG9D,8BAA+B;AAE/B,2DAA6D;AAC7D,+DAAuD;AACvD,uCAA+C;AAyC/C;;GAEG;AACH,MAAM,sBAAsB,GAAG,IAAI,GAAG,CAAuB;IAC3D,CAAC,MAAM,EAAE,OAAO,CAAC;IACjB,CAAC,MAAM,EAAE,OAAO,CAAC;IACjB,CAAC,OAAO,EAAE,UAAU,CAAC;IACrB,CAAC,MAAM,EAAE,OAAO,CAAC;IACjB,CAAC,MAAM,EAAE,OAAO,CAAC;IACjB,CAAC,KAAK,EAAE,QAAQ,CAAC;IACjB,CAAC,OAAO,EAAE,QAAQ,CAAC;IACnB,CAAC,MAAM,EAAE,OAAO,CAAC;IACjB,CAAC,OAAO,EAAE,OAAO,CAAC;IAClB,CAAC,OAAO,EAAE,MAAM,CAAC;IACjB,CAAC,QAAQ,EAAE,MAAM,CAAC;CACnB,CAAC,CAAC;AAEH;;GAEG;AACH,gCAAgC,GAAW;IACzC,OAAO,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;AACvD,CAAC;AAED;;;;GAIG;AACH,mCAAmC,aAAqB;IAEtD,MAAM,WAAW,GAAG,aAAa,CAAC,KAAK,CAAC;IACxC,IAAI,WAAW,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,WAAW,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;QAClE,OAAO,OAAO,CAAC;KAChB;IACD,IAAI,WAAW,CAAC,GAAG,CAAC,aAAa,CAAC,EAAE;QAClC,OAAO,UAAU,CAAC;KACnB;IACD,IAAI,WAAW,CAAC,GAAG,CAAC,aAAa,CAAC,EAAE;QAClC,OAAO,QAAQ,CAAC;KACjB;IACD,2EAA2E;IAC3E,8EAA8E;IAC9E,yCAAyC;IACzC,OAAO,sBAAsB,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;AACnD,CAAC;AAED;;GAEG;AACH,mCAAmC,aAAqB;IACtD,OAAO;QACL,IAAI,EAAE,yBAAyB,CAAC,aAAa,CAAC;QAC9C,MAAM,EAAE,CAAC;KACV,CAAC;AACJ,CAAC;AAED;;;GAGG;AACH,yCACI,QAAkB,EAClB,GAAgB;;QAClB,MAAM,QAAQ,GAAG,MAAM,QAAQ,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAC/C,MAAM,MAAM,GAAG,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QAEzC,IAAI,MAAM,CAAC,UAAU,KAAK,KAAK,EAAE;YAC/B,MAAM,OAAO,GAAG,MAAM,CAAC,KAAK,IAAI,MAAM,CAAC,KAAK,CAAC,OAAO,IAAI,SAAS,CAAC;YAClE,MAAM,IAAI,KAAK,CAAC,0BAA0B,GAAG,KAAK,OAAO,EAAE,CAAC,CAAC;SAC9D;QAED,MAAM,gBAAgB,GAAG,MAAM,CAAC,KAAK,CAAC;QACtC,MAAM,UAAU,GAAG,CAAC,GAAG,gBAAgB,CAAC,WAAW,CAAC;gBAClD,IAAI,EAAE,QAAQ;gBACd,gBAAgB,EAAE,IAAI;gBACtB,QAAQ,EAAE,IAAI;gBACd,aAAa,EAAE,IAAI;aACpB,CAAC,CAAC,CAAC;QACJ,MAAM,aAAa,GAAG,UAAU,CAAC,MAAM,CACnC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,aAAa,IAAI,CAAC,CAAC,IAAI,CAAC;YACxC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,4BAA4B,CAAC,CAAC,CAAC,CAAC;QACtD,MAAM,mBAAmB,GAAgC,EAAE,CAAC;QAE5D,KAAK,MAAM,cAAc,IAAI,aAAa,EAAE;YAC1C,iEAAiE;YACjE,iEAAiE;YACjE,8CAA8C;YAC9C,MAAM,iBAAiB,GAAG,cAAc,CAAC,GAAG,CAAC;YAC7C,MAAM,iBAAiB,GAAG,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;YAC3E,MAAM,mBAAmB,GAAG,mBAAmB,CAAC,iBAAiB,CAAC,CAAC;YACnE,IAAI,CAAC,mBAAmB,EAAE;gBACxB,mBAAmB,CAAC,iBAAiB,CAAC;oBAClC,yBAAyB,CAAC,cAAc,CAAC,CAAC;aAC/C;SACF;QAED,OAAO,mBAAmB,CAAC;IAC7B,CAAC;CAAA;AAGD;;;GAGG;AACH,qBAA6B,SAAQ,8BAAgC;IAOnE,YACI,MAAqB,EACrB,OAAqB,EACrB,QAA6B;QAC/B,KAAK,CAAC,EAAC,UAAU,EAAE,IAAI,EAAC,CAAC,CAAC;QAC1B,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG,EAAE,CAAC;QACvB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,2BAAQ,CAAC,EAAC,SAAS,EAAE,IAAI,sCAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,EAAC,CAAC,CAAC;QAC5E,IAAI,CAAC,OAAO;YACR,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,IAAI,oBAAoB,CAChD,CAAC;QAChB,IAAI,CAAC,QAAQ,GAAG,CAAC,QAAQ,IAAI,EAAE,CAAuB,CAAC;IACzD,CAAC;IAGG,cAAc,CAAC,KAA0B;;;gBAC3C,KAAyB,IAAA,UAAA,cAAA,KAAK,CAAA,WAAA;oBAAnB,MAAM,IAAI,iCAAA,CAAA;oBACnB,IAAI,CAAC,KAAK,CAAC,GAAG,CACV,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,+BAAW,CAChC,IAAI,CAAC,MAAM,CAAC,IAAmB,EAAE,IAAI,CAAC,IAAmB,CAAC,CAAE,EAChE,IAAI,CAAC,CAAC;oBACV,MAAM,IAAI,CAAC;iBACZ;;;;;;;;;YAED,yDAAyD;YACzD,MAAM,YAAY,GAAG,cAAM,IAAI,CAAC,oBAAoB,EAAE,CAAA,CAAC;YACvD,MAAM,oBAAoB,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;YAC3E,8CAA8C;YAC9C,MAAM,IAAI,IAAI,CAAC;gBACb,IAAI,EAAE,IAAI,CAAC,OAAO;gBAClB,QAAQ,EAAE,IAAI,MAAM,CAAC,oBAAoB,CAAC;aAC3C,CAAC,CAAC;;QACL,CAAC;KAAA;IAEK,oBAAoB;;YACxB,0EAA0E;YAC1E,2EAA2E;YAC3E,0EAA0E;YAC1E,MAAM,YAAY,GAAG,IAAI,GAAG,CACxB,CAAC,MAAM,2BAAc,CAChB,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,CACxB,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,+BAAW,CAC1C,IAAI,CAAC,MAAM,CAAC,IAAmB,EAAE,IAAmB,CAAC,CAAE,CAAC,EAChE,IAAI,CAAC,QAAQ,CAAC,CAAC;iBACf,IAAI,EAAE,CAAC,CAAC;YAEjB,yEAAyE;YACzE,8DAA8D;YAC9D,MAAM,qBAAqB,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,+BAAW,CAC9D,IAAI,CAAC,MAAM,CAAC,IAAmB,EAC/B,IAAI,CAAC,MAAM,CAAC,KAAoB;gBAC5B,IAAI,CAAC,MAAM,CAAC,UAAyB,CAAC,CAAE,CAAC;YACjD,YAAY,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC;YAExC,uDAAuD;YACvD,MAAM,YAAY,GAAiB,EAAE,CAAC;YACtC,KAAK,MAAM,QAAQ,IAAI,YAAY,EAAE;gBACnC,MAAM,mBAAmB,GACrB,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;gBACvD,YAAY,CAAC,mBAAmB,CAAC;oBAC7B,MAAM,+BAA+B,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;aACpE;YAED,yEAAyE;YACzE,4EAA4E;YAC5E,qBAAqB;YACrB,EAAE;YACF,2EAA2E;YAC3E,0EAA0E;YAC1E,wBAAwB;YACxB,qEAAqE;YACrE,qDAAqD;YACrD,MAAM,SAAS,GAAG,CAAC,CAAS,EAAE,EAAE,CAC5B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;YAE1D,MAAM,UAAU,GAAiB,EAAE,CAAC;YACpC,KAAK,MAAM,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE;gBAC9C,MAAM,OAAO,GAAgC,EAAE,CAAC;gBAChD,KAAK,MAAM,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,EAAE;oBACtD,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC;iBAC3D;gBACD,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,GAAG,OAAO,CAAC;aACzC;YACD,OAAO,UAAU,CAAC;QACpB,CAAC;KAAA;CACF;AA5FD,0CA4FC","file":"push-manifest.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as path from 'path';\nimport {Analyzer, Import, PackageRelativeUrl, ResolvedUrl} from 'polymer-analyzer';\nimport {buildDepsIndex} from 'polymer-bundler/lib/deps-index';\nimport {ProjectConfig} from 'polymer-project-config';\n\nimport File = require('vinyl');\n\nimport {urlFromPath, LocalFsPath} from './path-transformers';\nimport {FileMapUrlLoader} from './file-map-url-loader';\nimport {AsyncTransformStream} from './streams';\n\n/**\n * Push Manifest Types Definitions\n * A push manifest is a JSON object representing relative application URL and\n * the resources that should be pushed when those URLs are requested by the\n * server. Below is a example of this data format:\n *\n *       {\n *         \"index.html\": {       // PushManifestEntryCollection\n *           \"/css/app.css\": {   // PushManifestEntry\n *             \"type\": \"style\",  // ResourceType\n *             \"weight\": 1\n *           },\n *           ...\n *         },\n *         \"page.html\": {\n *           \"/css/page.css\": {\n *             \"type\": \"style\",\n *             \"weight\": 1\n *           },\n *           ...\n *         }\n *       }\n *\n * NOTE(fks) 04-05-2017: Only weight=1 is supported by browsers at the moment.\n * When support is added, we can add automatic weighting and support multiple\n * numbers.\n */\nexport type ResourceType = 'document'|'script'|'style'|'image'|'font';\nexport interface PushManifestEntry {\n  type?: ResourceType;\n  weight?: 1;\n}\nexport interface PushManifestEntryCollection {\n  [dependencyAbsoluteUrl: string]: PushManifestEntry;\n}\nexport interface PushManifest {\n  [requestAbsoluteUrl: string]: PushManifestEntryCollection;\n}\n\n/**\n * A mapping of file extensions and their default resource type.\n */\nconst extensionToTypeMapping = new Map<string, ResourceType>([\n  ['.css', 'style'],\n  ['.gif', 'image'],\n  ['.html', 'document'],\n  ['.png', 'image'],\n  ['.jpg', 'image'],\n  ['.js', 'script'],\n  ['.json', 'script'],\n  ['.svg', 'image'],\n  ['.webp', 'image'],\n  ['.woff', 'font'],\n  ['.woff2', 'font'],\n]);\n\n/**\n * Get the default resource type for a file based on its extension.\n */\nfunction getResourceTypeFromUrl(url: string): ResourceType|undefined {\n  return extensionToTypeMapping.get(path.extname(url));\n}\n\n/**\n * Get the resource type for an import, handling special import types and\n * falling back to getResourceTypeFromUrl() if the resource type can't be\n * detected directly from importFeature.\n */\nfunction getResourceTypeFromImport(importFeature: Import): ResourceType|\n    undefined {\n  const importKinds = importFeature.kinds;\n  if (importKinds.has('css-import') || importKinds.has('html-style')) {\n    return 'style';\n  }\n  if (importKinds.has('html-import')) {\n    return 'document';\n  }\n  if (importKinds.has('html-script')) {\n    return 'script';\n  }\n  // @NOTE(fks) 04-07-2017: A js-import can actually import multiple types of\n  // resources, so we can't guarentee that it's a script and should instead rely\n  // on the default file-extension mapping.\n  return getResourceTypeFromUrl(importFeature.url);\n}\n\n/**\n * Create a PushManifestEntry from an analyzer Import.\n */\nfunction createPushEntryFromImport(importFeature: Import): PushManifestEntry {\n  return {\n    type: getResourceTypeFromImport(importFeature),\n    weight: 1,\n  };\n}\n\n/**\n * Analyze the given URL and resolve with a collection of push manifest entries\n * to be added to the overall push manifest.\n */\nasync function generatePushManifestEntryForUrl(\n    analyzer: Analyzer,\n    url: ResolvedUrl): Promise<PushManifestEntryCollection> {\n  const analysis = await analyzer.analyze([url]);\n  const result = analysis.getDocument(url);\n\n  if (result.successful === false) {\n    const message = result.error && result.error.message || 'unknown';\n    throw new Error(`Unable to get document ${url}: ${message}`);\n  }\n\n  const analyzedDocument = result.value;\n  const rawImports = [...analyzedDocument.getFeatures({\n    kind: 'import',\n    externalPackages: true,\n    imported: true,\n    noLazyImports: true,\n  })];\n  const importsToPush = rawImports.filter(\n      (i) => !(i.type === 'html-import' && i.lazy) &&\n          !(i.kinds.has('html-script-back-reference')));\n  const pushManifestEntries: PushManifestEntryCollection = {};\n\n  for (const analyzedImport of importsToPush) {\n    // TODO This import URL does not respect the document's base tag.\n    // Probably an issue more generally with all URLs analyzed out of\n    // documents, but base tags are somewhat rare.\n    const analyzedImportUrl = analyzedImport.url;\n    const relativeImportUrl = analyzer.urlResolver.relative(analyzedImportUrl);\n    const analyzedImportEntry = pushManifestEntries[relativeImportUrl];\n    if (!analyzedImportEntry) {\n      pushManifestEntries[relativeImportUrl] =\n          createPushEntryFromImport(analyzedImport);\n    }\n  }\n\n  return pushManifestEntries;\n}\n\n\n/**\n * A stream that reads in files from an application to generate an HTTP2/Push\n * manifest that gets injected into the stream.\n */\nexport class AddPushManifest extends AsyncTransformStream<File, File> {\n  files: Map<ResolvedUrl, File>;\n  outPath: LocalFsPath;\n  private config: ProjectConfig;\n  private analyzer: Analyzer;\n  private basePath: PackageRelativeUrl;\n\n  constructor(\n      config: ProjectConfig,\n      outPath?: LocalFsPath,\n      basePath?: PackageRelativeUrl) {\n    super({objectMode: true});\n    this.files = new Map();\n    this.config = config;\n    this.analyzer = new Analyzer({urlLoader: new FileMapUrlLoader(this.files)});\n    this.outPath =\n        path.join(this.config.root, outPath || 'push-manifest.json') as\n        LocalFsPath;\n    this.basePath = (basePath || '') as PackageRelativeUrl;\n  }\n\n  protected async *\n      _transformIter(files: AsyncIterable<File>): AsyncIterable<File> {\n    for await (const file of files) {\n      this.files.set(\n          this.analyzer.resolveUrl(urlFromPath(\n              this.config.root as LocalFsPath, file.path as LocalFsPath))!,\n          file);\n      yield file;\n    }\n\n    // Generate a push manifest, and propagate any errors up.\n    const pushManifest = await this.generatePushManifest();\n    const pushManifestContents = JSON.stringify(pushManifest, undefined, '  ');\n    // Push the new push manifest into the stream.\n    yield new File({\n      path: this.outPath,\n      contents: new Buffer(pushManifestContents),\n    });\n  }\n\n  async generatePushManifest(): Promise<PushManifest> {\n    // Bundler's buildDepsIndex code generates an index with all fragments and\n    // all lazy-imports encountered are the keys, so we'll use that function to\n    // produce the set of all fragments to generate push-manifest entries for.\n    const allFragments = new Set(\n        (await buildDepsIndex(\n             this.config.allFragments.map(\n                 (path) => this.analyzer.resolveUrl(urlFromPath(\n                     this.config.root as LocalFsPath, path as LocalFsPath))!),\n             this.analyzer))\n            .keys());\n\n    // If an app-shell exists, use that as our main push URL because it has a\n    // reliable URL. Otherwise, support the single entrypoint URL.\n    const mainPushEntrypointUrl = this.analyzer.resolveUrl(urlFromPath(\n        this.config.root as LocalFsPath,\n        this.config.shell as LocalFsPath ||\n            this.config.entrypoint as LocalFsPath))!;\n    allFragments.add(mainPushEntrypointUrl);\n\n    // Generate the dependencies to push for each fragment.\n    const pushManifest: PushManifest = {};\n    for (const fragment of allFragments) {\n      const absoluteFragmentUrl =\n          '/' + this.analyzer.urlResolver.relative(fragment);\n      pushManifest[absoluteFragmentUrl] =\n          await generatePushManifestEntryForUrl(this.analyzer, fragment);\n    }\n\n    // The URLs we got may be absolute or relative depending on how they were\n    // declared in the source. This will normalize them to relative by stripping\n    // any leading slash.\n    //\n    // TODO Decide whether they should really be relative or absolute. Relative\n    // was chosen here only because most links were already relative so it was\n    // a smaller change, but\n    // https://github.com/GoogleChrome/http2-push-manifest actually shows\n    // relative for the keys and absolute for the values.\n    const normalize = (p: string) =>\n        path.posix.join(this.basePath, p).replace(/^\\/+/, '');\n\n    const normalized: PushManifest = {};\n    for (const source of Object.keys(pushManifest)) {\n      const targets: PushManifestEntryCollection = {};\n      for (const target of Object.keys(pushManifest[source])) {\n        targets[normalize(target)] = pushManifest[source][target];\n      }\n      normalized[normalize(source)] = targets;\n    }\n    return normalized;\n  }\n}\n"]}