{"version":3,"sources":["../src/babel-plugin-dynamic-import-amd.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;AAEH,sFAAuE;AAGvE,8CAAuC;AAEvC,MAAM,GAAG,GAAG,kBAAQ,CAAC,GAAG,CAAC;AAEzB;;GAEG;AACU,QAAA,gBAAgB,GAAG;IAC9B,QAAQ,EAAE,sCAAoB;IAE9B,OAAO,EAAE;QACP,OAAO,CAAC,IAAuB;YAC7B,uEAAuE;YACvE,uEAAuE;YACvE,0EAA0E;YAC1E,wEAAwE;YACxE,uCAAuC;YAEvC,4DAA4D;YAC5D,6CAA6C;YAC7C,MAAM,WAAW,GAAG,IAAI,GAAG,EAAU,CAAC;YACtC,MAAM,cAAc,GAA+B,EAAE,CAAC;YACtD,IAAI,CAAC,QAAQ,CAAC;gBACZ,cAAc,CAAC,IAA8B;oBAC3C,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAc,KAAK,QAAQ,EAAE;wBAChD,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;wBAC1B,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC;wBAC7C,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;4BACxC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;yBACvB;qBACF;gBACH,CAAC;aACF,CAAC,CAAC;YAEH,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC/B,OAAO;aACR;YAED,+CAA+C;YAC/C,IAAI,SAAS,GAAyB,SAAS,CAAC;YAChD,GAAG;gBACD,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC;aACzD,QAAQ,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;YAE1C,iCAAiC;YACjC,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,IAAmB,CAAC;YACjD,UAAU,CAAC,OAAO,CAAC,GAAG,CAAA,eAAe,SAAS,kBAAkB,CAAC,CAAC;YAElE,yCAAyC;YACzC,KAAK,MAAM,UAAU,IAAI,cAAc,EAAE;gBACvC,MAAM,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBAC/C,uEAAuE;gBACvE,qEAAqE;gBACrE,yCAAyC;gBACzC,UAAU,CAAC,WAAW,CAAC,GAAG,CAAA;sCACI,SAAS,aACnC,SAAS;UACX,CAAC,CAAC;aACL;QACH,CAAC;KACF;CACF,CAAC","file":"babel-plugin-dynamic-import-amd.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport dyanamicImportSyntax from '@babel/plugin-syntax-dynamic-import';\nimport {NodePath} from '@babel/traverse';\nimport {CallExpression, Identifier, Program, Statement} from 'babel-types';\nimport template from '@babel/template';\n\nconst ast = template.ast;\n\n/**\n * Rewrites dynamic import() calls to AMD async require() calls.\n */\nexport const dynamicImportAmd = {\n  inherits: dyanamicImportSyntax,\n\n  visitor: {\n    Program(path: NodePath<Program>) {\n      // We transform dynamic import() into a Promise whose initializer calls\n      // require(). We must use the \"local\" require - the one provided by the\n      // AMD loaded when a module explicitly depends on the \"require\" module ID.\n      // To get the emitted define() call to depend on \"require\", we inject an\n      // import of a module called \"require\".\n\n      // Collect all the NodePaths to dynamic import() expressions\n      // and all the identifiers in scope for them.\n      const identifiers = new Set<string>();\n      const dynamicImports: NodePath<CallExpression>[] = [];\n      path.traverse({\n        CallExpression(path: NodePath<CallExpression>) {\n          if (path.node.callee.type as string === 'Import') {\n            dynamicImports.push(path);\n            const bindings = path.scope.getAllBindings();\n            for (const name of Object.keys(bindings)) {\n              identifiers.add(name);\n            }\n          }\n        }\n      });\n\n      if (dynamicImports.length === 0) {\n        return;\n      }\n\n      // Choose a unique name to import \"require\" as.\n      let requireId: Identifier|undefined = undefined;\n      do {\n        requireId = path.scope.generateUidIdentifier('require');\n      } while (identifiers.has(requireId.name));\n\n      // Inject the import of \"require\"\n      const statements = path.node.body as Statement[];\n      statements.unshift(ast`import * as ${requireId} from 'require';`);\n\n      // Transform the dynamic import callsites\n      for (const importPath of dynamicImports) {\n        const specifier = importPath.node.arguments[0];\n        // Call as `require.default` because the AMD transformer that we assume\n        // is running next will rewrite `require` from a function to a module\n        // object with the function at `default`.\n        importPath.replaceWith(ast`(\n          new Promise((res, rej) => ${requireId}.default([${\n            specifier}], res, rej))\n        )`);\n      }\n    },\n  },\n};\n"]}