{"version":3,"sources":["../src/javascript/esutil.ts"],"names":[],"mappings":"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","file":"esutil.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as assert from 'assert';\nimport generate from '@babel/generator';\nimport babelTraverse from '@babel/traverse';\nimport {NodePath} from '@babel/traverse';\nimport * as babel from '@babel/types';\nimport * as doctrine from 'doctrine';\nimport * as util from 'util';\n\nimport {MethodParam, ScannedMethod, ScannedProperty} from '../index';\nimport {Result} from '../model/analysis';\nimport {ImmutableSet} from '../model/immutable';\nimport {Privacy} from '../model/model';\nimport {ScannedEvent, Severity, SourceRange, Warning} from '../model/model';\nimport {ParsedDocument} from '../parser/document';\nimport * as docs from '../polymer/docs';\nimport {annotateEvent} from '../polymer/docs';\n\nimport * as astValue from './ast-value';\nimport {JavaScriptDocument} from './javascript-document';\nimport * as jsdoc from './jsdoc';\n\n/**\n * Returns whether a Babel node matches a particular object path.\n *\n * e.g. you have a MemberExpression node, and want to see whether it represents\n * `Foo.Bar.Baz`:\n *    matchesCallExpressio\n    (node, ['Foo', 'Bar', 'Baz'])\n *\n * @param {babel.Node} expression The Babel node to match against.\n * @param {Array<string>} path The path to look for.\n */\nexport function matchesCallExpression(\n    expression: babel.MemberExpression, path: string[]): boolean {\n  if (!expression.property || !expression.object) {\n    return false;\n  }\n  assert(path.length >= 2);\n\n  if (!babel.isIdentifier(expression.property)) {\n    return false;\n  }\n  // Unravel backwards, make sure properties match each step of the way.\n  if (expression.property.name !== path[path.length - 1]) {\n    return false;\n  }\n  // We've got ourselves a final member expression.\n  if (path.length === 2 && babel.isIdentifier(expression.object)) {\n    return expression.object.name === path[0];\n  }\n  // Nested expressions.\n  if (path.length > 2 && babel.isMemberExpression(expression.object)) {\n    return matchesCallExpression(\n        expression.object, path.slice(0, path.length - 1));\n  }\n\n  return false;\n}\n\nexport type PropertyOrMethod = babel.ObjectProperty|babel.ObjectMethod|\n                               babel.ClassMethod|babel.AssignmentProperty;\n\n/**\n * Given a property or method, return its name, or undefined if that name can't\n * be determined.\n */\nexport function getPropertyName(prop: PropertyOrMethod): string|undefined {\n  const key = prop.key;\n  // {foo: bar} // note that `foo` is not quoted, so it's an identifier\n  if (!prop.computed && babel.isIdentifier(key)) {\n    return key.name;\n  }\n\n  // Otherwise, try to statically evaluate the expression\n  const keyValue = astValue.expressionToValue(key);\n  if (keyValue !== undefined) {\n    return '' + keyValue;\n  }\n  return undefined;\n}\n\n/**\n * Yields properties and methods, filters out spread expressions or anything\n * else.\n */\nexport function* getSimpleObjectProperties(node: babel.ObjectExpression) {\n  for (const property of node.properties) {\n    if (babel.isObjectProperty(property) || babel.isObjectMethod(property)) {\n      yield property;\n    }\n  }\n}\n\n/** Like getSimpleObjectProperties but deals with paths. */\nexport function*\n    getSimpleObjectPropPaths(nodePath: NodePath<babel.ObjectExpression>) {\n  // tslint:disable-next-line: no-any typings are wrong here\n  const props = nodePath.get('properties') as any as Array<NodePath>;\n  for (const propPath of props) {\n    if (propPath.isObjectProperty() || propPath.isObjectMethod()) {\n      yield propPath;\n    }\n  }\n}\n\nexport const CLOSURE_CONSTRUCTOR_MAP = new Map(\n    [['Boolean', 'boolean'], ['Number', 'number'], ['String', 'string']]);\n\nconst VALID_EXPRESSION_TYPES = new Map([\n  ['ArrayExpression', 'Array'],\n  ['BlockStatement', 'Function'],\n  ['BooleanLiteral', 'boolean'],\n  ['FunctionExpression', 'Function'],\n  ['NullLiteral', 'null'],\n  ['NumericLiteral', 'number'],\n  ['ObjectExpression', 'Object'],\n  ['RegExpLiteral', 'RegExp'],\n  ['StringLiteral', 'string'],\n  ['TemplateLiteral', 'string'],\n]);\n\n/**\n * AST expression -> Closure type.\n *\n * Accepts literal values, and native constructors.\n *\n * @param {Node} node A Babel expression node.\n * @return {string} The type of that expression, in Closure terms.\n */\nexport function getClosureType(\n    node: babel.Node,\n    parsedJsdoc: doctrine.Annotation|undefined,\n    sourceRange: SourceRange,\n    document: ParsedDocument): Result<string, Warning> {\n  if (parsedJsdoc) {\n    const typeTag = jsdoc.getTag(parsedJsdoc, 'type');\n    if (typeTag) {\n      return {successful: true, value: doctrine.type.stringify(typeTag.type!)};\n    }\n  }\n  const type = VALID_EXPRESSION_TYPES.get(node.type);\n  if (type) {\n    return {successful: true, value: type};\n  }\n  if (babel.isIdentifier(node)) {\n    return {\n      successful: true,\n      value: CLOSURE_CONSTRUCTOR_MAP.get(node.name) || node.name\n    };\n  }\n  const warning = new Warning({\n    code: 'no-closure-type',\n    message: `Unable to determine closure type for expression of type ` +\n        `${node.type}`,\n    severity: Severity.WARNING,\n    sourceRange,\n    parsedDocument: document,\n  });\n  return {successful: false, error: warning};\n}\n\n/**\n * Tries to find the comment for the given node.\n *\n * Will look up the tree at comments on parents as appropriate, but should\n * not look at unrelated nodes. Stops at the nearest statement boundary.\n */\nexport function getBestComment(nodePath: NodePath): string|undefined {\n  const maybeComment = getAttachedComment(nodePath.node);\n  if (maybeComment !== undefined) {\n    return maybeComment;\n  }\n\n  const parent = nodePath.parentPath;\n  if (parent === undefined) {\n    return undefined;\n  }\n  if (!isStatementWithUniqueStatementChild(parent.node) &&\n      babel.isStatement(nodePath.node)) {\n    // Don't walk up above the nearest statement.\n    return undefined;\n  }\n  if (babel.isVariableDeclaration(parent.node) &&\n      parent.node.declarations.length !== 1) {\n    // The parent node is multiple declarations. We can't be sure its\n    // comment applies to us.\n    return undefined;\n  }\n\n  if (parent.isClassBody() || nodePath.isObjectMember()) {\n    // don't go above an object or class member.\n    return undefined;\n  }\n\n  return getBestComment(parent);\n}\n\nexport function getAttachedComment(node: babel.Node): string|undefined {\n  const comments = getLeadingComments(node) || [];\n  return comments && comments[comments.length - 1];\n}\n\n/**\n * Returns all comments from a tree defined with @event.\n */\nexport function getEventComments(node: babel.Node): Map<string, ScannedEvent> {\n  const eventComments = new Set<string>();\n\n  babelTraverse(node, {\n    enter(path: NodePath) {\n      const node = path.node;\n      [...(node.leadingComments || []), ...(node.trailingComments || [])]\n          .map((commentAST) => commentAST.value)\n          .filter((comment) => comment.indexOf('@event') !== -1)\n          .forEach((comment) => eventComments.add(comment));\n    },\n    noScope: true,\n  });\n  const events = [...eventComments]\n                     .map(\n                         (comment) => annotateEvent(jsdoc.parseJsdoc(\n                             jsdoc.removeLeadingAsterisks(comment).trim())))\n                     .filter((ev) => !!ev)\n                     .sort((ev1, ev2) => ev1.name.localeCompare(ev2.name));\n  return new Map(events.map((e) => [e.name, e] as [string, ScannedEvent]));\n}\n\nfunction getLeadingComments(node: babel.Node): string[]|undefined {\n  if (!node) {\n    return;\n  }\n  const comments = [];\n  for (const comment of node.leadingComments || []) {\n    // Espree says any comment that immediately precedes a node is\n    // \"leading\", but we want to be stricter and require them to be\n    // touching. If we don't have locations for some reason, err on the\n    // side of including the comment.\n    if (!node.loc || !comment.loc ||\n        node.loc.start.line - comment.loc.end.line < 2) {\n      comments.push(comment.value);\n    }\n  }\n  return comments.length ? comments : undefined;\n}\n\nexport function getPropertyValue(\n    node: babel.ObjectExpression, name: string): babel.Node|undefined {\n  for (const property of getSimpleObjectProperties(node)) {\n    if (getPropertyName(property) === name) {\n      return property.value;\n    }\n  }\n}\n\n/**\n * Create a ScannedMethod object from an estree Property AST node.\n */\nexport function toScannedMethod(\n    node: babel.ObjectProperty|babel.ObjectMethod|babel.ClassMethod,\n    sourceRange: SourceRange,\n    document: JavaScriptDocument): ScannedMethod {\n  const parsedJsdoc = jsdoc.parseJsdoc(getAttachedComment(node) || '');\n  const description = parsedJsdoc.description.trim();\n  const maybeName = getPropertyName(node);\n\n  const warnings: Warning[] = [];\n  if (!maybeName) {\n    warnings.push(new Warning({\n      code: 'unknown-method-name',\n      message: `Could not determine name of method from expression of type: ` +\n          `${node.key.type}`,\n      sourceRange: sourceRange,\n      severity: Severity.INFO,\n      parsedDocument: document\n    }));\n  }\n\n  const value = babel.isObjectProperty(node) ? node.value : node;\n\n  const result = getClosureType(value, parsedJsdoc, sourceRange, document);\n  const type = result.successful === true ? result.value : 'Function';\n\n  const name = maybeName || '';\n  const scannedMethod: ScannedMethod = {\n    name,\n    type,\n    description,\n    sourceRange,\n    warnings,\n    astNode: {language: 'js', node, containingDocument: document},\n    jsdoc: parsedJsdoc,\n    privacy: getOrInferPrivacy(name, parsedJsdoc)\n  };\n\n  if (value && babel.isFunction(value)) {\n    if (scannedMethod.jsdoc !== undefined) {\n      scannedMethod.return = getReturnFromAnnotation(scannedMethod.jsdoc);\n    }\n    if (scannedMethod.return === undefined) {\n      scannedMethod.return = inferReturnFromBody(value);\n    }\n\n    scannedMethod.params =\n        (value.params ||\n         []).map((nodeParam) => toMethodParam(nodeParam, scannedMethod.jsdoc));\n  }\n\n  return scannedMethod;\n}\n\nexport function getReturnFromAnnotation(jsdocAnn: jsdoc.Annotation):\n    {type?: string, desc?: string}|undefined {\n  const tag =\n      jsdoc.getTag(jsdocAnn, 'return') || jsdoc.getTag(jsdocAnn, 'returns');\n\n  if (!tag || (!tag.type && !tag.description)) {\n    return undefined;\n  }\n\n  const type: {type?: string, desc?: string} = {};\n\n  if (tag && (tag.type || tag.description)) {\n    if (tag.type) {\n      type.type = doctrine.type.stringify(tag.type);\n    }\n    if (tag.description) {\n      type.desc = tag.description;\n    }\n  }\n\n  return type;\n}\n\n/**\n * Examine the body of a function to see if we can infer something about its\n * return type. This currently only handles the case where a function definitely\n * returns void.\n */\nexport function inferReturnFromBody(node: babel.Function): {type: string}|\n    undefined {\n  if (node.async === true || node.generator === true) {\n    // Async functions always return promises, and generators always return\n    // iterators, so they are never void.\n    return undefined;\n  }\n  if (babel.isArrowFunctionExpression(node) &&\n      !babel.isBlockStatement(node.body)) {\n    // An arrow function that immediately returns a value (e.g. () => 'foo').\n    return undefined;\n  }\n  let returnsVoid = true;\n  babelTraverse(node, {\n    ReturnStatement(path) {\n      const statement = path.node;\n      // The typings claim that statement.argument is always an Expression, but\n      // actually when there is no argument it is null.\n      if (statement.argument !== null) {\n        returnsVoid = false;\n        path.stop();\n      }\n    },\n    // If this function contains another function, don't traverse into it. Only\n    // return statements in the immediate function scope matter.\n    FunctionDeclaration(path) {\n      path.skip();\n    },\n    FunctionExpression(path) {\n      path.skip();\n    },\n    ClassMethod(path) {\n      path.skip();\n    },\n    ArrowFunctionExpression(path) {\n      path.skip();\n    },\n    ObjectMethod(path) {\n      path.skip();\n    },\n\n    noScope: true\n  });\n  if (returnsVoid) {\n    return {type: 'void'};\n  }\n  return undefined;\n}\n\nexport function toMethodParam(\n    nodeParam: babel.LVal, jsdocAnn?: jsdoc.Annotation): MethodParam {\n  const paramTags = new Map<string, doctrine.Tag>();\n  let name;\n  let defaultValue;\n  let rest;\n\n  if (jsdocAnn) {\n    for (const tag of (jsdocAnn.tags || [])) {\n      if (tag.title === 'param' && tag.name) {\n        paramTags.set(tag.name, tag);\n      }\n    }\n  }\n\n  if (babel.isIdentifier(nodeParam)) {\n    // Basic parameter: method(param)\n    name = nodeParam.name;\n\n  } else if (\n      babel.isRestElement(nodeParam) &&\n      babel.isIdentifier(nodeParam.argument)) {\n    // Rest parameter: method(...param)\n    name = nodeParam.argument.name;\n    rest = true;\n\n  } else if (\n      babel.isAssignmentPattern(nodeParam) &&\n      babel.isIdentifier(nodeParam.left)) {\n    // Parameter with a default: method(param = \"default\")\n    name = nodeParam.left.name;\n    defaultValue = generate(nodeParam.right).code;\n\n  } else {\n    // Some AST pattern we don't recognize. Hope the code generator does\n    // something reasonable.\n    name = generate(nodeParam).code;\n  }\n\n  let type;\n  let description;\n  const tag = paramTags.get(name);\n  if (tag) {\n    if (tag.type) {\n      type = doctrine.type.stringify(tag.type);\n    }\n    if (tag.description) {\n      description = tag.description;\n    }\n  }\n\n  const param: MethodParam = {name, type, defaultValue, rest, description};\n  return param;\n}\n\nexport function getOrInferPrivacy(\n    name: string,\n    annotation: jsdoc.Annotation|undefined,\n    defaultPrivacy: Privacy = 'public'): Privacy {\n  const explicitPrivacy = jsdoc.getPrivacy(annotation);\n  const specificName = name.slice(name.lastIndexOf('.') + 1);\n\n  if (explicitPrivacy) {\n    return explicitPrivacy;\n  }\n  if (specificName.startsWith('__')) {\n    return 'private';\n  } else if (specificName.startsWith('_')) {\n    return 'protected';\n  } else if (specificName.endsWith('_')) {\n    return 'private';\n  } else if (configurationProperties.has(specificName)) {\n    return 'protected';\n  }\n  return defaultPrivacy;\n}\n\n/**\n * Properties on element prototypes that are part of the custom elment\n * lifecycle or Polymer configuration syntax.\n *\n * TODO(rictic): only treat the Polymer ones as private when dealing with\n *   Polymer.\n */\nexport const configurationProperties: ImmutableSet<string> = new Set([\n  'attached',\n  'attributeChanged',\n  'beforeRegister',\n  'configure',\n  'constructor',\n  'created',\n  'detached',\n  'enableCustomStyleProperties',\n  'extends',\n  'hostAttributes',\n  'is',\n  'listeners',\n  'mixins',\n  'observers',\n  'properties',\n  'ready',\n  'registered',\n]);\n\n/**\n * Scan any methods on the given node, if it's a class expression/declaration.\n */\nexport function getMethods(node: babel.Node, document: JavaScriptDocument):\n    Map<string, ScannedMethod> {\n  const methods = new Map<string, ScannedMethod>();\n  for (const statement of _getMethods(node)) {\n    if (statement.static === false) {\n      const method = toScannedMethod(\n          statement, document.sourceRangeForNode(statement)!, document);\n      docs.annotate(method);\n      methods.set(method.name, method);\n    }\n  }\n  return methods;\n}\n\nexport function getConstructorMethod(\n    astNode: babel.Node, document: JavaScriptDocument): ScannedMethod|\n    undefined {\n  if (!babel.isClass(astNode)) {\n    return;\n  }\n\n  const statement = getConstructorClassMethod(astNode);\n\n  if (statement) {\n    const method = toScannedMethod(\n        statement, document.sourceRangeForNode(statement)!, document);\n    const typeTag = getReturnFromAnnotation(\n        jsdoc.parseJsdoc(getAttachedComment(statement) || ''));\n\n    if (typeTag) {\n      method.return = {...method.return, ...typeTag};\n    } else {\n      method.return = undefined;\n    }\n\n    return method;\n  }\n}\n\nexport function getConstructorClassMethod(astNode: babel.Class):\n    babel.ClassMethod|undefined {\n  for (const member of astNode.body.body) {\n    if (babel.isClassMethod(member) && member.kind === 'constructor') {\n      return member;\n    }\n  }\n}\n\n/**\n * Scan any static methods on the given node, if it's a class\n * expression/declaration.\n */\nexport function getStaticMethods(\n    node: babel.Node,\n    document: JavaScriptDocument): Map<string, ScannedMethod> {\n  const methods = new Map<string, ScannedMethod>();\n  for (const method of _getMethods(node)) {\n    if (method.static === true) {\n      const scannedMethod = toScannedMethod(\n          method, document.sourceRangeForNode(method)!, document);\n      docs.annotate(scannedMethod);\n      methods.set(scannedMethod.name, scannedMethod);\n    }\n  }\n  return methods;\n}\n\nfunction* _getMethods(node: babel.Node) {\n  if (!babel.isClassDeclaration(node) && !babel.isClassExpression(node)) {\n    return;\n  }\n  for (const statement of node.body.body) {\n    if (babel.isClassMethod(statement) && statement.kind === 'method') {\n      yield statement;\n    }\n  }\n}\n\n/*\n * Extracts a property from a given getter or setter method,\n * whether it be an object method or a class method.\n */\nexport function extractPropertyFromGetterOrSetter(\n    method: babel.ClassMethod|babel.ObjectMethod,\n    jsdocAnn: jsdoc.Annotation|undefined,\n    document: JavaScriptDocument): ScannedProperty|null {\n  // TODO(43081j): remove this when static properties are supported\n  if (babel.isClassMethod(method) && method.static) {\n    return null;\n  }\n\n  if (method.kind !== 'get' && method.kind !== 'set') {\n    return null;\n  }\n\n  // TODO(43081j): use getPropertyName, see\n  // https://github.com/Polymer/polymer-analyzer/pull/867\n  const name = getPropertyName(method);\n  if (name === undefined) {\n    return null;\n  }\n\n  let type;\n  let description;\n  let privacy: Privacy = 'public';\n  let readOnly = false;\n\n  if (jsdocAnn) {\n    const ret = getReturnFromAnnotation(jsdocAnn);\n    type = ret ? ret.type : undefined;\n    description = jsdoc.getDescription(jsdocAnn);\n    privacy = getOrInferPrivacy(name, jsdocAnn);\n    readOnly = jsdoc.hasTag(jsdocAnn, 'readonly');\n  }\n\n  return {\n    name,\n    astNode: {language: 'js', node: method, containingDocument: document},\n    type,\n    jsdoc: jsdocAnn,\n    sourceRange: document.sourceRangeForNode(method)!,\n    description,\n    privacy,\n    warnings: [],\n    readOnly,\n  };\n}\n\n/**\n * Extracts properties (including accessors) from a given class\n * or object expression.\n */\nexport function extractPropertiesFromClassOrObjectBody(\n    node: babel.Class|babel.ObjectExpression,\n    document: JavaScriptDocument): Map<string, ScannedProperty> {\n  const properties = new Map<string, ScannedProperty>();\n  const accessors = new Map<string, {\n    getter?: babel.ClassMethod | babel.ObjectMethod,\n    setter?: babel.ClassMethod | babel.ObjectMethod\n  }>();\n\n  let body;\n\n  if (babel.isClass(node)) {\n    body = node.body.body;\n  } else {\n    body = node.properties;\n  }\n\n  for (const member of body) {\n    if (!babel.isMethod(member) && !babel.isObjectProperty(member)) {\n      continue;\n    }\n\n    const name = getPropertyName(member);\n    if (name === undefined) {\n      continue;\n    }\n\n    if (babel.isMethod(member) || babel.isFunction(member.value)) {\n      if (babel.isMethod(member) &&\n          (member.kind === 'get' || member.kind === 'set')) {\n        let accessor = accessors.get(name);\n\n        if (!accessor) {\n          accessor = {};\n          accessors.set(name, accessor);\n        }\n\n        if (member.kind === 'get') {\n          accessor.getter = member;\n        } else {\n          accessor.setter = member;\n        }\n      }\n\n      continue;\n    }\n\n    const astNode = member.key;\n    const sourceRange = document.sourceRangeForNode(member)!;\n    const jsdocAnn = jsdoc.parseJsdoc(getAttachedComment(member) || '');\n    const detectedType =\n        getClosureType(member.value, jsdocAnn, sourceRange, document);\n    let type: string|undefined = undefined;\n\n    if (detectedType.successful) {\n      type = detectedType.value;\n    }\n\n    properties.set(name, {\n      name,\n      astNode: {language: 'js', node: astNode, containingDocument: document},\n      type,\n      jsdoc: jsdocAnn,\n      sourceRange,\n      description: jsdocAnn ? jsdoc.getDescription(jsdocAnn) : undefined,\n      privacy: getOrInferPrivacy(name, jsdocAnn),\n      warnings: [],\n      readOnly: jsdoc.hasTag(jsdocAnn, 'readonly'),\n    });\n  }\n\n  for (const val of accessors.values()) {\n    let getter: ScannedProperty|null = null;\n    let setter: ScannedProperty|null = null;\n\n    if (val.getter) {\n      const parsedJsdoc =\n          jsdoc.parseJsdoc(getAttachedComment(val.getter) || '');\n      getter =\n          extractPropertyFromGetterOrSetter(val.getter, parsedJsdoc, document);\n    }\n\n    if (val.setter) {\n      const parsedJsdoc =\n          jsdoc.parseJsdoc(getAttachedComment(val.setter) || '');\n      setter =\n          extractPropertyFromGetterOrSetter(val.setter, parsedJsdoc, document);\n    }\n\n    const prop = getter || setter;\n    if (!prop) {\n      continue;\n    }\n\n    if (!prop.readOnly) {\n      prop.readOnly = (val.setter === undefined);\n    }\n\n    properties.set(prop.name, prop);\n  }\n\n  return properties;\n}\n\n/**\n * Get the canonical statement or declaration for the given node.\n *\n * It would otherwise be difficult, or require specialized code for each kind of\n * feature, to determine which node is the canonical node for a feature. This\n * function is simple, it only walks up, and it stops once it reaches a clear\n * feature boundary. And since we're calling this function both on the indexing\n * and the lookup sides, we can be confident that both will agree on the same\n * node.\n *\n * There may be more than one feature within a single statement (e.g. `export\n * class Foo {}` is both a Class and an Export, but between `kind` and `id` we\n * should still have enough info to narrow down to the intended feature.\n *\n * See `DeclaredWithStatement` and `BaseDocumentQuery` to see where this is\n * used.\n */\nexport function getCanonicalStatement(nodePath: NodePath): babel.Statement|\n    undefined {\n  const node = nodePath.node;\n  const parent = nodePath.parentPath;\n  if ((parent && !isStatementWithUniqueStatementChild(parent.node)) &&\n      babel.isStatement(node)) {\n    return node;\n  }\n  if (parent != null) {\n    return getCanonicalStatement(parent);\n  }\n  return undefined;\n}\n\n/**\n * Some statements have many statments as children, like a BlockStatement.\n *\n * Some statements have a single unique statement child, like\n * ExportNamedDeclaration or ExportDefaultDeclaration. When we're talking up the\n * node tree but we want to stay within a single statement, we don't want to\n * walk up to a BlockStatement, as that's a group of many statements, but we do\n * want to walk up to ExportNamedDeclaration.\n */\nfunction isStatementWithUniqueStatementChild(node: babel.Node): boolean {\n  return babel.isExportNamedDeclaration(node) ||\n      babel.isExportDefaultDeclaration(node);\n}\n\n/** What names does a declaration assign to? */\nexport function*\n    getBindingNamesFromDeclaration(declaration: babel.Declaration|null|\n                                   undefined): IterableIterator<string> {\n  if (declaration == null) {\n    return;\n  }\n  switch (declaration.type) {\n    case 'ClassDeclaration':\n    case 'DeclareClass':\n      yield declaration.id.name;\n      break;\n    case 'VariableDeclaration':\n      for (const varDecl of declaration.declarations) {\n        yield* getNamesFromLValue(varDecl.id);\n      }\n      break;\n    case 'FunctionDeclaration':\n    case 'DeclareFunction':\n    case 'DeclareInterface':\n    case 'DeclareTypeAlias':\n    case 'InterfaceDeclaration':\n    case 'DeclareVariable':\n    case 'TypeAlias':\n      yield declaration.id.name;\n      break;\n    case 'ExportAllDeclaration':\n      // Can't do this syntactically. See Export#resolve.\n      break;\n    case 'ExportDefaultDeclaration':\n      yield 'default';\n      break;\n    case 'ExportNamedDeclaration':\n      for (const specifier of declaration.specifiers) {\n        if (specifier.exported.type === 'Identifier') {\n          yield specifier.exported.name;\n        }\n      }\n      yield* getBindingNamesFromDeclaration(declaration.declaration);\n      break;\n    case 'DeclareModule':\n      if (declaration.id.type === 'StringLiteral') {\n        yield declaration.id.value;\n      } else {\n        yield declaration.id.name;\n      }\n      break;\n    case 'ImportDeclaration':\n      for (const specifier of declaration.specifiers) {\n        yield specifier.local.name;\n      }\n      break;\n    default:\n      assertNever(declaration);\n  }\n}\n\n/**\n * Given an LValue, what are the names it assigns to?\n *\n * Internal utility function for getBindingNamesFromDeclaration.\n */\nfunction* getNamesFromLValue(lhs: babel.LVal): IterableIterator<string> {\n  switch (lhs.type) {\n    case 'Identifier':\n      // x = _;\n      yield lhs.name;\n      break;\n    case 'ArrayPattern':\n      // [a, b, c] = _;\n      for (const element of lhs.elements) {\n        if (babel.isLVal(element)) {\n          yield* getNamesFromLValue(element);\n        }\n      }\n      break;\n    case 'RestElement':\n      // the `...more` part of either\n      // [a, b, ...more] = _;\n      // {a: b, ...more} = _;\n      yield* getNamesFromLValue(lhs.argument);\n      break;\n    case 'MemberExpression':\n      // foo.bar = _;\n      const name = astValue.getIdentifierName(lhs);\n      if (name !== undefined) {\n        yield name;\n      }\n      break;\n    case 'ObjectPattern':\n      // {a: b, c} = _;\n      for (const prop of lhs.properties) {\n        switch (prop.type) {\n          case 'ObjectProperty':\n            // If the property has a 'value' (like)\n            yield* getNamesFromLValue(prop.value);\n            break;\n          case 'RestProperty':\n            yield* getNamesFromLValue(prop.argument);\n            break;\n          default:\n            assertNever(prop);\n        }\n      }\n      break;\n    case 'AssignmentPattern':\n      // var [a = 'defaultVal'] = _;\n      yield* getNamesFromLValue(lhs.left);\n      break;\n    default:\n      assertNever(lhs);\n  }\n}\n\nfunction assertNever(never: never): never {\n  throw new Error(`Unexpected ast node: ${util.inspect(never)}`);\n}\n"]}