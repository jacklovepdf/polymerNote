{"version":3,"sources":["../src/javascript/javascript-document.ts"],"names":[],"mappings":"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","file":"javascript-document.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport generate from '@babel/generator';\nimport * as babel from '@babel/types';\nimport {Node} from '@babel/types';\nimport indent = require('indent');\n\nimport {SourceRange} from '../model/model';\nimport {Options as ParsedDocumentOptions, ParsedDocument, StringifyOptions} from '../parser/document';\n\nimport {traverse, VisitorOption} from './estraverse-shim';\nimport {Visitor, VisitResult} from './estree-visitor';\nimport {NodePath} from '@babel/traverse';\n\nexport {Visitor} from './estree-visitor';\n\n/**\n * babel.Node#type is one of around a hundred string literals. We don't have\n * a direct reference to the type that represents any of those string literals\n * though. We can get a reference by taking a Node and using the `typeof`\n * operator, and it doesn't need to be a real Node as all of this happens at\n * analysis time, and nothing happens at runtime.\n */\n// tslint:disable-next-line: no-any\nconst __exampleNode: Node = null as any;\ntype EstreeType = typeof __exampleNode.type;\ninterface SkipRecord {\n  type: EstreeType;\n  depth: number;\n}\n\nexport interface Options extends ParsedDocumentOptions<babel.File> {\n  parsedAsSourceType: 'script'|'module';\n}\n\nexport class JavaScriptDocument extends ParsedDocument<Node, Visitor> {\n  readonly type = 'js';\n  private visitorSkips = new Map<Visitor, SkipRecord>();\n  ast!: babel.File;  // assigned in super, this type is just a refinement.\n\n  /**\n   * How the js document was parsed. If 'module' then the source code is\n   * definitely an ES6 module, as it has imports or exports. If 'script' then\n   * it may be an ES6 module with no imports or exports, or it may be a\n   * script.\n   */\n  parsedAsSourceType: 'script'|'module';\n\n  constructor(from: Options) {\n    super(from);\n    this.parsedAsSourceType = from.parsedAsSourceType;\n  }\n\n  visit(visitors: Visitor[]) {\n    /**\n     * Applies all visiting callbacks from `visitors`.\n     */\n    const applyScanners =\n        (callbackName: keyof Visitor,\n         node: Node,\n         parent: Node|null,\n         path: NodePath) => {\n          for (const visitor of visitors) {\n            if (_shouldSkip(visitor, callbackName, node.type)) {\n              continue;\n            }\n            if (callbackName in visitor) {\n              // TODO(rictic): is there a maintainable way to enforce the\n              //     mapping between callback names and the types of the first\n              //     arg?\n              const result: VisitResult =\n                  // tslint:disable-next-line: no-any\n                  (visitor as any)[callbackName](node, parent, path);\n              if (result) {\n                handleVisitorResult(result, callbackName, visitor, node.type);\n              }\n            }\n          }\n        };\n\n    // a visitor to break early, or to skip a subtree of the AST. We need to\n    // track this ourselves because we're running all the visitors at once.\n    const _shouldSkip =\n        (visitor: Visitor,\n         callbackName: string,\n         nodeType: typeof __exampleNode.type) => {\n          const skipRecord = this.visitorSkips.get(visitor);\n          if (!skipRecord) {\n            return false;\n          }\n          if (callbackName === `enter${nodeType}`) {\n            skipRecord.depth += 1;\n            return true;\n          } else if (callbackName === `leave${nodeType}`) {\n            skipRecord.depth -= 1;\n            if (skipRecord.depth === 0) {\n              this.visitorSkips.delete(visitor);\n              // Note that we don't `continue` here. This is deliberate so that\n              // we call the leave handler for the node where we started\n              // skipping.\n            } else {\n              return true;\n            }\n          } else {\n            return true;\n          }\n        };\n\n    const handleVisitorResult =\n        (visitorOption: VisitorOption,\n         callbackName: string,\n         visitor: Visitor,\n         nodeType: typeof __exampleNode.type) => {\n          switch (visitorOption) {\n            case VisitorOption.Remove:\n              throw new Error(\n                  `estraverse.VisitorOption.Remove not ` +\n                  `supported by JavascriptDocument`);\n            case VisitorOption.Break:\n              visitors = visitors.filter((v) => v !== visitor);\n              break;\n            case VisitorOption.Skip:\n              if (callbackName.startsWith('leave')) {\n                throw new Error(\n                    `estraverse.VisitorOption.Skip was returned from ` +\n                    `${callbackName} but it's not supported in a leave method`);\n              }\n              this.visitorSkips.set(visitor, {type: nodeType, depth: 1});\n              break;\n          }\n        };\n\n    traverse(this.ast, {\n      enter(node: Node, parent: Node, path) {\n        applyScanners(`enter${node.type}` as keyof Visitor, node, parent, path);\n      },\n      leave(node: Node, parent: Node, path) {\n        applyScanners(`leave${node.type}` as keyof Visitor, node, parent, path);\n      }\n    });\n  }\n  protected _sourceRangeForNode(node: Node): SourceRange|undefined {\n    if (!node || !node.loc) {\n      return;\n    }\n    return {\n      file: this.url,\n      // Note: estree uses 1-indexed lines, but SourceRange uses 0 indexed.\n      start: {line: (node.loc.start.line - 1), column: node.loc.start.column},\n      end: {line: (node.loc.end.line - 1), column: node.loc.end.column}\n    };\n  }\n\n  stringify(options: StringifyOptions) {\n    options = options || {};\n    const formatOptions = {\n      comments: true,\n      retainLines: false,\n      quotes: 'single' as 'single',\n    };\n\n    const code = generate(this.ast, formatOptions).code + '\\n';\n    return options.indent != null ? indent(code, options.indent * 2) : code;\n  }\n}\n"]}