{"version":3,"sources":["../src/javascript/namespace-scanner.ts"],"names":[],"mappings":"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","file":"namespace-scanner.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as babel from '@babel/types';\n\nimport {Result} from '../model/analysis';\nimport {ScannedProperty, Warning} from '../model/model';\n\nimport {getIdentifierName, getNamespacedIdentifier} from './ast-value';\nimport {Visitor} from './estree-visitor';\nimport * as esutil from './esutil';\nimport {JavaScriptDocument} from './javascript-document';\nimport {JavaScriptScanner} from './javascript-scanner';\nimport * as jsdoc from './jsdoc';\nimport {ScannedNamespace} from './namespace';\n\n/**\n * Find namespaces from source code.\n */\nexport class NamespaceScanner implements JavaScriptScanner {\n  async scan(\n      document: JavaScriptDocument,\n      visit: (visitor: Visitor) => Promise<void>) {\n    const visitor = new NamespaceVisitor(document);\n\n    await visit(visitor);\n\n    return {\n      features: [...visitor.namespaces.values()],\n      warnings: visitor.warnings\n    };\n  }\n}\n\nclass NamespaceVisitor implements Visitor {\n  namespaces = new Map<string, ScannedNamespace>();\n  document: JavaScriptDocument;\n  warnings: Warning[] = [];\n\n  constructor(document: JavaScriptDocument) {\n    this.document = document;\n  }\n\n  /**\n   * Look for object declarations with @namespace in the docs.\n   */\n  enterVariableDeclaration(\n      node: babel.VariableDeclaration, _parent: babel.Node) {\n    if (node.declarations.length !== 1) {\n      return;  // Ambiguous.\n    }\n    this._initNamespace(node, node.declarations[0].id);\n  }\n\n  /**\n   * Look for object assignments with @namespace in the docs.\n   */\n  enterAssignmentExpression(\n      node: babel.AssignmentExpression, parent: babel.Node) {\n    this._initNamespace(parent, node.left);\n  }\n\n  enterObjectProperty(node: babel.ObjectProperty, _parent: babel.Node) {\n    this._initNamespace(node, node.key);\n  }\n\n  enterExpressionStatement(node: babel.ExpressionStatement) {\n    if (!babel.isAssignmentExpression(node.expression) &&\n        !babel.isMemberExpression(node.expression)) {\n      return;\n    }\n\n    const jsdocAnn = jsdoc.parseJsdoc(esutil.getAttachedComment(node) || '');\n\n    if (!jsdoc.hasTag(jsdocAnn, 'memberof')) {\n      return;\n    }\n\n    const memberofTag = jsdoc.getTag(jsdocAnn, 'memberof');\n    const namespaceName = memberofTag && memberofTag.description;\n    let prop: ScannedProperty|undefined = undefined;\n    let namespacedIdentifier: string|undefined;\n\n    if (!namespaceName || !this.namespaces.has(namespaceName)) {\n      return;\n    }\n\n    if (babel.isAssignmentExpression(node.expression)) {\n      if (babel.isFunctionExpression(node.expression.right)) {\n        return;\n      }\n      namespacedIdentifier = getIdentifierName(node.expression.left);\n    } else if (babel.isMemberExpression(node.expression)) {\n      namespacedIdentifier = getIdentifierName(node.expression);\n    }\n\n    if (!namespacedIdentifier ||\n        namespacedIdentifier.indexOf('.prototype.') !== -1) {\n      return;\n    }\n\n    const namespace = this.namespaces.get(namespaceName)!;\n    const name = namespacedIdentifier.substring(\n        namespacedIdentifier.lastIndexOf('.') + 1);\n\n    prop = this._createPropertyFromExpression(name, node.expression, jsdocAnn);\n\n    if (prop) {\n      namespace.properties.set(name, prop);\n    }\n  }\n\n  private _createPropertyFromExpression(\n      name: string, node: babel.AssignmentExpression|babel.MemberExpression,\n      jsdocAnn: jsdoc.Annotation|undefined): ScannedProperty|undefined {\n    let description;\n    let type;\n    let readOnly = false;\n    const privacy = esutil.getOrInferPrivacy(name, jsdocAnn);\n    const sourceRange = this.document.sourceRangeForNode(node)!;\n    const warnings: Warning[] = [];\n\n    if (jsdocAnn) {\n      description = jsdoc.getDescription(jsdocAnn);\n      readOnly = jsdoc.hasTag(jsdocAnn, 'readonly');\n    }\n\n    let detectedType: Result<string, Warning>;\n\n    if (babel.isAssignmentExpression(node)) {\n      detectedType = esutil.getClosureType(\n          node.right, jsdocAnn, sourceRange, this.document);\n    } else {\n      detectedType =\n          esutil.getClosureType(node, jsdocAnn, sourceRange, this.document);\n    }\n\n    if (detectedType.successful) {\n      type = detectedType.value;\n    } else {\n      warnings.push(detectedType.error);\n      type = '?';\n    }\n\n    return {\n      name,\n      astNode: {language: 'js', node, containingDocument: this.document},\n      type,\n      jsdoc: jsdocAnn,\n      sourceRange,\n      description,\n      privacy,\n      warnings,\n      readOnly,\n    };\n  }\n\n  private _initNamespace(node: babel.Node, nameNode: babel.Node) {\n    const comment = esutil.getAttachedComment(node);\n    // Quickly filter down to potential candidates.\n    if (!comment || comment.indexOf('@namespace') === -1) {\n      return;\n    }\n    const analyzedName = getIdentifierName(nameNode);\n    const docs = jsdoc.parseJsdoc(comment);\n    const namespaceTag = jsdoc.getTag(docs, 'namespace');\n    const explicitName = namespaceTag && namespaceTag.name;\n    let namespaceName;\n    if (explicitName) {\n      namespaceName = explicitName;\n    } else if (analyzedName) {\n      namespaceName = getNamespacedIdentifier(analyzedName, docs);\n    } else {\n      // TODO(fks): Propagate a warning if name could not be determined\n      return;\n    }\n\n    const sourceRange = this.document.sourceRangeForNode(node);\n    if (!sourceRange) {\n      throw new Error(\n          `Unable to determine sourceRange for @namespace: ${comment}`);\n    }\n\n    const summaryTag = jsdoc.getTag(docs, 'summary');\n    const summary = (summaryTag && summaryTag.description) || '';\n    const description = docs.description;\n    const properties = getNamespaceProperties(node, this.document);\n\n    this.namespaces.set(\n        namespaceName,\n        new ScannedNamespace(\n            namespaceName,\n            description,\n            summary,\n            {language: 'js', node, containingDocument: this.document},\n            properties,\n            docs,\n            sourceRange));\n  }\n}\n\n/**\n * Extracts properties from a given namespace node.\n */\nfunction getNamespaceProperties(node: babel.Node, document: JavaScriptDocument):\n    Map<string, ScannedProperty> {\n  const properties = new Map<string, ScannedProperty>();\n  let child: babel.ObjectExpression;\n\n  if (babel.isVariableDeclaration(node)) {\n    if (node.declarations.length !== 1) {\n      return properties;\n    }\n\n    const declaration = node.declarations[0].init;\n\n    if (!babel.isObjectExpression(declaration)) {\n      return properties;\n    }\n\n    child = declaration;\n  } else if (\n      babel.isExpressionStatement(node) &&\n      babel.isAssignmentExpression(node.expression) &&\n      babel.isObjectExpression(node.expression.right)) {\n    child = node.expression.right;\n  } else {\n    return properties;\n  }\n\n  return esutil.extractPropertiesFromClassOrObjectBody(child, document);\n}\n"]}