{"version":3,"sources":["../src/javascript/ast-value.ts"],"names":[],"mappings":"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","file":"ast-value.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as babel from '@babel/types';\n\nimport {LiteralObj, LiteralValue} from '../model/model';\n\nimport {getPropertyName, getSimpleObjectProperties} from './esutil';\nimport * as jsdoc from './jsdoc';\n\n/**\n * Converts an ast literal to its underlying value.\n */\nfunction literalToValue(literal: babel.Literal): LiteralValue {\n  if (babel.isBooleanLiteral(literal) || babel.isNumericLiteral(literal) ||\n      babel.isStringLiteral(literal)) {\n    return literal.value;\n  }\n  if (babel.isNullLiteral(literal)) {\n    return null;\n  }\n  if (babel.isTemplateLiteral(literal)) {\n    return templateLiteralToValue(literal);\n  }\n  // Any other literal value is treated as undefined.\n  return undefined;\n}\n\nfunction templateLiteralToValue(literal: babel.TemplateLiteral): LiteralValue {\n  const len = literal.quasis.length - 1;\n  let value: LiteralValue = '';\n\n  for (let i = 0; i < len; i++) {\n    value += literal.quasis[i].value.raw;\n    const v = expressionToValue(literal.expressions[i]);\n    if (v === undefined) {\n      return;\n    }\n\n    value += `${v}`;\n  }\n\n  value += literal.quasis[len].value.raw;\n\n  return value;\n}\n\n/**\n * Early evaluates a unary expression.\n */\nfunction unaryToValue(unary: babel.UnaryExpression): LiteralValue {\n  const operand = expressionToValue(unary.argument);\n  switch (unary.operator) {\n    case '!':\n      // tslint:disable-next-line: no-any Aping JS semantics, this is ok.\n      return !(operand as any);\n    case '-':\n      // tslint:disable-next-line: no-any Aping JS semantics, this is ok.\n      return -(operand as any);\n    case '+':\n      // tslint:disable-next-line: no-any Aping JS semantics, this is ok.\n      return +(operand as any);\n    case '~':\n      // tslint:disable-next-line: no-any Aping JS semantics, this is ok.\n      return ~(operand as any);\n    case 'typeof':\n      return typeof operand;\n    case 'void':\n      return void operand;\n    case 'delete':\n      return undefined;\n    default:\n      const never: never = unary.operator;\n      throw new Error(`Unknown unary operator found: ${never}`);\n  }\n}\n\n/**\n * Try to evaluate function bodies.\n */\nfunction functionDeclarationToValue(fn: babel.FunctionDeclaration):\n    LiteralValue {\n  if (babel.isBlockStatement(fn.body)) {\n    return blockStatementToValue(fn.body);\n  }\n}\n\nfunction functionExpressionToValue(fn: babel.FunctionExpression): LiteralValue {\n  if (babel.isBlockStatement(fn.body)) {\n    return blockStatementToValue(fn.body);\n  }\n}\n\nfunction arrowFunctionExpressionToValue(fn: babel.ArrowFunctionExpression):\n    LiteralValue {\n  if (babel.isBlockStatement(fn.body)) {\n    return blockStatementToValue(fn.body);\n  } else {\n    return expressionToValue(fn.body);\n  }\n}\n\n/**\n * Block statement: find last return statement, and return its value\n */\nfunction blockStatementToValue(block: babel.BlockStatement): LiteralValue {\n  for (let i = block.body.length - 1; i >= 0; i--) {\n    const body = block.body[i];\n    if (babel.isReturnStatement(body)) {\n      return returnStatementToValue(body);\n    }\n  }\n}\n\n/**\n * Evaluates return's argument\n */\nfunction returnStatementToValue(ret: babel.ReturnStatement): LiteralValue {\n  return expressionToValue(\n      ret.argument || {type: 'Literal', value: null, raw: 'null'});\n}\n\n/**\n * Evaluate array expression\n */\nfunction arrayExpressionToValue(arry: babel.ArrayExpression): LiteralValue {\n  const value: LiteralValue[] = [];\n  for (let i = 0; i < arry.elements.length; i++) {\n    const v = expressionToValue(arry.elements[i]);\n    if (v === undefined) {\n      continue;\n    }\n    value.push(v);\n  }\n  return value;\n}\n\n/**\n * Evaluate object expression\n */\nfunction objectExpressionToValue(obj: babel.ObjectExpression): LiteralValue {\n  const evaluatedObjectExpression: LiteralObj = {};\n  for (const prop of getSimpleObjectProperties(obj)) {\n    const evaluatedKey = getPropertyName(prop);\n    if (evaluatedKey === undefined) {\n      return;\n    }\n    const evaluatedValue = expressionToValue(prop.value);\n    if (evaluatedValue === undefined) {\n      return;\n    }\n    evaluatedObjectExpression[evaluatedKey] = evaluatedValue;\n  }\n  return evaluatedObjectExpression;\n}\n\n/**\n * Binary expressions, like 5 + 5\n */\nfunction binaryExpressionToValue(member: babel.BinaryExpression):\n    (number|string|undefined) {\n  const left = expressionToValue(member.left);\n  const right = expressionToValue(member.right);\n  if (left == null || right == null) {\n    return;\n  }\n  if (member.operator === '+') {\n    // We need to cast to `any` here because, while it's usually not the right\n    // thing to do to use '+' on two values of a mix of types because it's\n    // unpredictable, that is what the original code we're evaluating does.\n    // tslint:disable-next-line: no-any Aping JS semantics, this is ok.\n    return <any>left + right;\n  }\n  return;\n}\n\n/**\n * Tries to get the value of an expression. Returns undefined on failure.\n */\nexport function expressionToValue(valueExpression: babel.Node): LiteralValue {\n  if (babel.isLiteral(valueExpression)) {\n    return literalToValue(valueExpression);\n  }\n  if (babel.isUnaryExpression(valueExpression)) {\n    return unaryToValue(valueExpression);\n  }\n  if (babel.isFunctionDeclaration(valueExpression)) {\n    return functionDeclarationToValue(valueExpression);\n  }\n  if (babel.isFunctionExpression(valueExpression)) {\n    return functionExpressionToValue(valueExpression);\n  }\n  if (babel.isArrowFunctionExpression(valueExpression)) {\n    return arrowFunctionExpressionToValue(valueExpression);\n  }\n  if (babel.isArrayExpression(valueExpression)) {\n    return arrayExpressionToValue(valueExpression);\n  }\n  if (babel.isObjectExpression(valueExpression)) {\n    return objectExpressionToValue(valueExpression);\n  }\n  if (babel.isBinaryExpression(valueExpression)) {\n    return binaryExpressionToValue(valueExpression);\n  }\n}\n\n/**\n * Extracts the name of the identifier or `.` separated chain of identifiers.\n *\n * Returns undefined if the given node isn't a simple identifier or chain of\n * simple identifiers.\n */\nexport function getIdentifierName(node: babel.Node): string|undefined {\n  if (babel.isIdentifier(node)) {\n    return node.name;\n  }\n  if (babel.isMemberExpression(node)) {\n    const object = getIdentifierName(node.object);\n    let property;\n    if (node.computed) {\n      property = expressionToValue(node.property);\n    } else {\n      property = getIdentifierName(node.property);\n    }\n    if (object != null && property != null) {\n      return `${object}.${property}`;\n    }\n  }\n}\n\n/**\n * Formats the given identifier name under a namespace, if one is mentioned in\n * the commentedNode's comment. Otherwise, name is returned.\n */\nexport function getNamespacedIdentifier(\n    name: string, docs?: jsdoc.Annotation): string {\n  if (!docs) {\n    return name;\n  }\n  const memberofTag = jsdoc.getTag(docs, 'memberof');\n  const namespace = memberofTag && memberofTag.description;\n  if (namespace) {\n    const rightMostIdentifierName = name.substring(name.lastIndexOf('.') + 1);\n    return namespace + '.' + rightMostIdentifierName;\n  } else {\n    return name;\n  }\n}\n\nexport const CANT_CONVERT = 'UNKNOWN';\n"]}