{"version":3,"sources":["../src/javascript/resolve-specifier-node.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;AAEH,wCAAwC;AACxC,uCAAwC;AACxC,+BAA6C;AAC7C,wCAAwC;AAGxC,MAAM,YAAY,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;AAC/C,MAAM,eAAe,GAAG,CAAC,CAAS,EAAE,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAE5D;;;;;;;;;;;;GAYG;AACU,QAAA,OAAO,GAChB,CAAC,SAAiB,EAAE,YAAoB,EAAE,aAIzC,EAAmB,EAAE;IACpB,IAAI,SAAS,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,IAAI,EAAE;QAC1C,OAAO,SAA4B,CAAC;KACrC;IAED,MAAM,gBAAgB,GAAG,YAAY,CAAC;IAEtC,MAAM,kBAAkB,GAAG,WAAW,CAAC,IAAI,CAAC,SAAS,EAAE;QACrD,OAAO,EAAE,cAAO,CAAC,gBAAgB,CAAC;QAElC,qEAAqE;QACrE,oDAAoD;QACpD,oEAAoE;QACpE,4DAA4D;QAC5D,kEAAkE;QAClE,mEAAmE;QACnE,WAAW;QACX,UAAU,EAAE,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC;QAErC,mEAAmE;QACnE,kEAAkE;QAClE,aAAa,EACT,CAAC,WAC4D,EAAE,EAAE;YAC/D,WAAW,CAAC,IAAI,GAAG,WAAW,CAAC,MAAM;gBACjC,WAAW,CAAC,aAAa,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC;YACnD,OAAO,WAAW,CAAC;QACrB,CAAC;KACN,CAAC,CAAC;IAEH,IAAI,oBAAoB,GACpB,eAAQ,CAAC,cAAO,CAAC,gBAAgB,CAAC,EAAE,kBAAkB,CACvC,CAAC;IAEpB,IAAI,aAAa,KAAK,SAAS,EAAE;QAC/B,oEAAoE;QACpE,wEAAwE;QACxE,wEAAwE;QACxE,oBAAoB;QACpB,EAAE;QACF,oEAAoE;QACpE,2DAA2D;QAC3D,MAAM,EAAC,WAAW,EAAE,OAAO,EAAE,YAAY,EAAC,GAAG,aAAa,CAAC;QAE3D,MAAM,qBAAqB,GACvB,CAAC,YAAY,CAAC,gBAAgB,EAAE,YAAY,CAAC,CAAC;QAElD,MAAM,uBAAuB,GACzB,CAAC,YAAY,CAAC,kBAAkB,EAAE,YAAY,CAAC,CAAC;QAEpD,IAAI,qBAAqB,IAAI,CAAC,uBAAuB,EAAE;YACrD,oEAAoE;YACpE,oEAAoE;YACpE,6DAA6D;YAC7D,qEAAqE;YACrE,+BAA+B;YAC/B,EAAE;YACF,oEAAoE;YACpE,8DAA8D;YAC9D,oCAAoC;YACpC,MAAM,wBAAwB,GAAG,eAAQ,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;YACrE,MAAM,yBAAyB,GAC3B,WAAI,CAAC,YAAY,EAAE,WAAW,EAAE,wBAAwB,CAAC,CAAC;YAC9D,oBAAoB,GAAG,eAAQ,CACJ,cAAO,CAAC,yBAAyB,CAAC,EAClC,kBAAkB,CAAoB,CAAC;SACnE;KACF;IAED,IAAI,SAAS,EAAE,EAAE;QACf,0CAA0C;QAC1C,oBAAoB;YAChB,oBAAoB,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAoB,CAAC;KACjE;IAED,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,EAAE;QAC1C,oBAAoB,GAAG,IAAI,GAAG,oBAAuC,CAAC;KACvE;IAED,OAAO,oBAAoB,CAAC;AAC9B,CAAC,CAAC","file":"resolve-specifier-node.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as whatwgUrl from 'whatwg-url';\nimport nodeResolve = require('resolve');\nimport {dirname, relative, join} from 'path';\nimport * as isWindows from 'is-windows';\nimport {FileRelativeUrl} from '../model/model';\n\nconst pathIsInside = require('path-is-inside');\nconst isPathSpecifier = (s: string) => /^\\.{0,2}\\//.test(s);\n\n/**\n * Resolves module specifiers using node module resolution.\n *\n * Full URLs - those parsable by the WHATWG URL spec - are returned as-is.\n * Absolute and relative paths are resolved, even though they are valid\n * HTML-spec module specifiers, because node resolution supports directories\n * and omitting extensions. If a specifier doesn't resolve, it's returned as-is.\n *\n * @param componentInfo An object describing a \"component-style\" URL layout. In\n *   this layout, cross-package URLs reach out of the package directory to\n *   sibling packages, rather than into the component directory. When given,\n *   this parameter causes relative paths to be returns for this style.\n */\nexport const resolve =\n    (specifier: string, documentPath: string, componentInfo?: {\n      packageName: string,\n      rootDir: string,\n      componentDir: string\n    }): FileRelativeUrl => {\n      if (whatwgUrl.parseURL(specifier) !== null) {\n        return specifier as FileRelativeUrl;\n      }\n\n      const importerFilepath = documentPath;\n\n      const dependencyFilepath = nodeResolve.sync(specifier, {\n        basedir: dirname(importerFilepath),\n\n        // It's invalid to load a .json or .node file as a module on the web,\n        // but this is what Node's resolution algorithm does\n        // (https://nodejs.org/api/modules.html#modules_all_together), so we\n        // also do it here for completeness. Without including these\n        // extensions the user will probably get a 404. With them, they'll\n        // probably get an invalid MIME type error (which is hopefully more\n        // useful).\n        extensions: ['.js', '.json', '.node'],\n\n        // Some packages use a non-standard alternative to the \"main\" field\n        // in their package.json to differentiate their ES module version.\n        packageFilter:\n            (packageJson:\n                 {main?: string, module?: string, 'jsnext:main'?: string}) => {\n              packageJson.main = packageJson.module ||\n                  packageJson['jsnext:main'] || packageJson.main;\n              return packageJson;\n            },\n      });\n\n      let relativeSpecifierUrl =\n          relative(dirname(importerFilepath), dependencyFilepath) as\n          FileRelativeUrl;\n\n      if (componentInfo !== undefined) {\n        // Special handling for servers like Polyserve which, when serving a\n        // package \"foo\", will map the URL \"/components/foo\" to the root package\n        // directory, so that \"foo\" can make correct relative path references to\n        // its dependencies.\n        //\n        // Note that Polyserve will only set componentInfo if the particular\n        // request was for a URL path in the components/ directory.\n        const {packageName, rootDir, componentDir} = componentInfo;\n\n        const importerInRootPackage =\n            !pathIsInside(importerFilepath, componentDir);\n\n        const dependencyInRootPackage =\n            !pathIsInside(dependencyFilepath, componentDir);\n\n        if (importerInRootPackage && !dependencyInRootPackage) {\n          // A module from the root package, served from a components/ URL, is\n          // importing a module from a different package. In this case we need\n          // to fix up our relative path specifier, because on disk the\n          // dependency resolves to e.g. \"./node_modules/foo\", but in URL space\n          // it must resolve to \"../foo\".\n          //\n          // Note that the case where both the importer and the dependency are\n          // in the root package does not need to be fixed up, since the\n          // relative path works out the same.\n          const rootRelativeImporterPath = relative(rootDir, importerFilepath);\n          const effectiveImporterFilepath =\n              join(componentDir, packageName, rootRelativeImporterPath);\n          relativeSpecifierUrl = relative(\n                                     dirname(effectiveImporterFilepath),\n                                     dependencyFilepath) as FileRelativeUrl;\n        }\n      }\n\n      if (isWindows()) {\n        // normalize path separators to URL format\n        relativeSpecifierUrl =\n            relativeSpecifierUrl.replace(/\\\\/g, '/') as FileRelativeUrl;\n      }\n\n      if (!isPathSpecifier(relativeSpecifierUrl)) {\n        relativeSpecifierUrl = './' + relativeSpecifierUrl as FileRelativeUrl;\n      }\n\n      return relativeSpecifierUrl;\n    };\n"]}