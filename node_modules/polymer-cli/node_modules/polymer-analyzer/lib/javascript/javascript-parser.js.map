{"version":3,"sources":["../src/javascript/javascript-parser.ts"],"names":[],"mappings":"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","file":"javascript-parser.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as babel from '@babel/types';\nimport * as babylon from 'babylon';\n\nimport {correctSourceRange, InlineDocInfo, LocationOffset, Severity, SourceRange, Warning, WarningCarryingException} from '../model/model';\nimport {ResolvedUrl} from '../model/url';\nimport {UnparsableParsedDocument} from '../parser/document';\nimport {Parser} from '../parser/parser';\nimport {UrlResolver} from '../url-loader/url-resolver';\n\nimport {JavaScriptDocument} from './javascript-document';\n\nexport type SourceType = 'script'|'module';\n\ndeclare class SyntaxError {\n  message: string;\n  lineNumber: number;\n  column: number;\n}\n\nconst baseParseOptions: babylon.BabylonOptions = {\n  plugins: [\n    'asyncGenerators',\n    'dynamicImport',\n    // tslint:disable-next-line: no-any Remove this once typings updated.\n    'importMeta' as any,\n    'objectRestSpread',\n  ],\n};\n\n// TODO(usergenic): Move this to regular baseParseOptions declaration once\n// @types/babylon has been updated to include `ranges`.\n// tslint:disable-next-line: no-any\n(baseParseOptions as any)['ranges'] = true;\n\nexport class JavaScriptParser implements Parser<JavaScriptDocument> {\n  readonly sourceType?: SourceType;\n\n  parse(\n      contents: string, url: ResolvedUrl, _urlResolver: UrlResolver,\n      inlineInfo?: InlineDocInfo): JavaScriptDocument {\n    const isInline = !!inlineInfo;\n    inlineInfo = inlineInfo || {};\n    const result = parseJs(\n        contents, url, inlineInfo.locationOffset, undefined, this.sourceType);\n    if (result.type === 'failure') {\n      // TODO(rictic): define and return a ParseResult instead of throwing.\n      const minimalDocument = new UnparsableParsedDocument(url, contents);\n      throw new WarningCarryingException(\n          new Warning({parsedDocument: minimalDocument, ...result.warningish}));\n    }\n\n    return new JavaScriptDocument({\n      url,\n      contents,\n      baseUrl: inlineInfo.baseUrl,\n      ast: result.parsedFile,\n      locationOffset: inlineInfo.locationOffset,\n      astNode: inlineInfo.astNode,\n      isInline,\n      parsedAsSourceType: result.sourceType,\n    });\n  }\n}\n\nexport class JavaScriptModuleParser extends JavaScriptParser {\n  readonly sourceType: SourceType = 'module';\n}\n\nexport class JavaScriptScriptParser extends JavaScriptParser {\n  readonly sourceType: SourceType = 'script';\n}\n\nexport type ParseResult = {\n  type: 'success',\n  sourceType: SourceType,\n  parsedFile: babel.File,\n}|{\n  type: 'failure',\n  warningish: {\n    sourceRange: SourceRange,\n    severity: Severity,\n    code: string,\n    message: string,\n  }\n};\n\n/**\n * Parse the given contents and return either an AST or a parse error as a\n * Warning. It needs the filename and the location offset to produce correct\n * warnings.\n */\nexport function parseJs(\n    contents: string,\n    file: ResolvedUrl,\n    locationOffset?: LocationOffset,\n    warningCode?: string,\n    sourceType?: SourceType): ParseResult {\n  if (!warningCode) {\n    warningCode = 'parse-error';\n  }\n\n  let parsedFile: babel.File;\n  const parseOptions = {sourceFilename: file, ...baseParseOptions};\n\n  try {\n    // If sourceType is not provided, we will try script first and if that\n    // fails, we will try module, since failure is probably that it can't\n    // parse the 'import' or 'export' syntax as a script.\n    if (!sourceType) {\n      try {\n        sourceType = 'script';\n        parsedFile = babylon.parse(contents, {sourceType, ...parseOptions});\n      } catch (_ignored) {\n        sourceType = 'module';\n        parsedFile = babylon.parse(contents, {sourceType, ...parseOptions});\n      }\n    } else {\n      parsedFile = babylon.parse(contents, {sourceType, ...parseOptions});\n    }\n    return {\n      type: 'success',\n      sourceType: sourceType,\n      parsedFile,\n    };\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      updateLineNumberAndColumnForError(err);\n      return {\n        type: 'failure',\n        warningish: {\n          message: err.message.split('\\n')[0],\n          severity: Severity.ERROR,\n          code: warningCode,\n          sourceRange: correctSourceRange(\n              {\n                file,\n                start: {line: err.lineNumber - 1, column: err.column - 1},\n                end: {line: err.lineNumber - 1, column: err.column - 1}\n              },\n              locationOffset)!,\n        }\n      };\n    }\n    throw err;\n  }\n}\n\n/**\n * Babylon does not provide lineNumber and column values for unexpected token\n * syntax errors.  This function parses the `(line:column)` value from the\n * message of these errors and updates the error object in place.\n */\nfunction updateLineNumberAndColumnForError(err: SyntaxError) {\n  if (typeof err.lineNumber === 'number' && typeof err.column === 'number') {\n    return;\n  }\n  if (!err.message) {\n    return;\n  }\n  const lineAndColumnMatch =\n      err.message.match(/(Unexpected token.*)\\(([0-9]+):([0-9]+)\\)/);\n  if (!lineAndColumnMatch) {\n    return;\n  }\n  err.lineNumber = parseInt(lineAndColumnMatch[2], 10);\n  err.column = parseInt(lineAndColumnMatch[3], 10) + 1;\n}\n"]}