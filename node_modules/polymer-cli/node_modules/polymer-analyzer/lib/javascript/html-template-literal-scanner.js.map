{"version":3,"sources":["../src/javascript/html-template-literal-scanner.ts"],"names":[],"mappings":"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","file":"html-template-literal-scanner.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as babel from '@babel/types';\n\nimport {ScannedInlineDocument} from '../model/model';\n\nimport {getIdentifierName} from './ast-value';\nimport {Visitor} from './estree-visitor';\nimport {JavaScriptDocument} from './javascript-document';\nimport {JavaScriptScanner} from './javascript-scanner';\n\n/**\n * Finds inline HTML documents in Javascript source.\n *\n * e.g.\n *     html`<div></div>`;\n */\nexport class InlineHtmlDocumentScanner implements JavaScriptScanner {\n  async scan(\n      document: JavaScriptDocument,\n      visit: (visitor: Visitor) => Promise<void>) {\n    const features: ScannedInlineDocument[] = [];\n\n    const myVisitor: Visitor = {\n      enterTaggedTemplateExpression(node) {\n        const tagName = getIdentifierName(node.tag);\n        if (tagName === undefined || !/(^|\\.)html$/.test(tagName)) {\n          return;\n        }\n        const inlineDocument = getInlineDocument(node, document);\n        if (inlineDocument !== undefined) {\n          features.push(inlineDocument);\n        }\n      }\n    };\n\n    await visit(myVisitor);\n\n    return {features};\n  }\n}\n\nexport interface Options {\n  /**\n   * If true, uses the \"raw\" template string contents rather than the \"cooked\"\n   * contents. For example: raw contents yields `\\n` as two characters, cooked\n   * yields it as a newline.\n   */\n  useRawContents?: boolean;\n}\n\n/**\n * Parses the given string as an inline HTML document.\n */\nexport function getInlineDocument(\n    node: babel.TaggedTemplateExpression,\n    parsedDocument: JavaScriptDocument,\n    options: Options = {}): ScannedInlineDocument|undefined {\n  const sourceRangeForLiteral = parsedDocument.sourceRangeForNode(node.quasi);\n  if (sourceRangeForLiteral === undefined) {\n    return;\n  }\n  const sourceRangeForContents = {\n    file: sourceRangeForLiteral.file,\n    start: {\n      line: sourceRangeForLiteral.start.line,\n      column: sourceRangeForLiteral.start.column + 1\n    },\n    end: {\n      line: sourceRangeForLiteral.end.line,\n      column: sourceRangeForLiteral.end.column - 1\n    }\n  };\n\n  let contents = '';\n  let previousEnd: number|undefined;\n  for (const quasi of node.quasi.quasis) {\n    if (previousEnd !== undefined) {\n      const fullExpressionTextWithDelimitors =\n          parsedDocument.contents.slice(previousEnd, quasi.start);\n      /**\n       * Replace everything but whitespace in ${expressions} (including the\n       * ${} delimitor part) with whitespace.\n       * This skips over the problem of handling expressions, and there's lots\n       * of cases it doesn't handle correctly, but it's a start.\n       * Consider the js file:\n       * ```js\n       *   html`<div>${\n       *     'Hello world'\n       *   }</div>\n       * ```\n       *\n       * If we remove the expression entirely, the html parser receives\n       * `<div></div>` and when we ask for the source range of the closing tag\n       * it'll give one on the first line, and starting just after the `<div>`.\n       * By preserving whitespace and replacing every other character with a\n       * space, the HTML parser will receive\n       *\n       * ```html\n       *   <div>\n       *     (a bunch of spaces on this line)\n       *    </div>\n       * ```\n       *\n       * and so the html parser's source locations will map cleanly onto offsets\n       * in the original template literal (excluding characters like `\\n`). We\n       * could do something more sophisticated later, but this works for most\n       * cases and is quick and easy to implement.\n       */\n      contents += fullExpressionTextWithDelimitors.replace(/\\S/g, ' ');\n    }\n    if (options.useRawContents) {\n      contents += quasi.value.raw;\n    } else {\n      contents += quasi.value.cooked;\n    }\n    previousEnd = quasi.end;\n  }\n\n  let commentText;\n  if (node.leadingComments != null) {\n    commentText = node.leadingComments.map((c) => c.value).join('\\n');\n  } else {\n    commentText = '';\n  }\n\n  return new ScannedInlineDocument(\n      'html',\n      contents,\n      {\n        filename: sourceRangeForContents.file,\n        col: sourceRangeForContents.start.column,\n        line: sourceRangeForContents.start.line\n      },\n      commentText,\n      sourceRangeForContents,\n      {language: 'js', node, containingDocument: parsedDocument});\n}\n"]}