{"version":3,"sources":["../src/editor-service/ast-from-source-position.ts"],"names":[],"mappings":"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","file":"ast-from-source-position.js","sourcesContent":["/**\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as parse5 from 'parse5';\n\nimport {ParsedHtmlDocument} from '../html/html-document';\nimport {comparePositionAndRange, isPositionInsideRange, SourcePosition} from '../model/model';\n\n\nexport type LocationResult = AttributesSection|AttributeValue|TagName|EndTag|\n    TextNode|ScriptContents|StyleContents|Comment;\n\n/** In the tagname of a start tag. */\nexport interface TagName {\n  kind: 'tagName';\n  element: parse5.ASTNode;\n}\n/** In an end tag. */\nexport interface EndTag {\n  kind: 'endTag';\n  element: parse5.ASTNode;\n}\n\n/** In the attributes section of a start tag. Maybe in an attribute name. */\nexport interface AttributesSection {\n  kind: 'attribute';\n  /** The attribute name that we're hovering over, if any. */\n  attribute: string|null;\n  /** The element whose start tag we're in. */\n  element: parse5.ASTNode;\n}\n\n/** In the value of an attribute of a start tag. */\nexport interface AttributeValue {\n  kind: 'attributeValue';\n  attribute: string;\n  element: parse5.ASTNode;\n}\n\n/** In a text node. */\nexport interface TextNode {\n  kind: 'text';\n  textNode?: parse5.ASTNode;\n}\n/** In the text of a <script> */\nexport interface ScriptContents {\n  kind: 'scriptTagContents';\n  textNode?: parse5.ASTNode;\n}\n\n/** In the text of a <style> */\nexport interface StyleContents {\n  kind: 'styleTagContents';\n  textNode?: parse5.ASTNode;\n}\n\n/** In a <!-- comment --> */\nexport interface Comment {\n  kind: 'comment';\n  commentNode: parse5.ASTNode;\n}\n\n/**\n * Given a position and an HTML document, try to describe what new text typed\n * at the given position would be.\n *\n * Where possible we try to return the ASTNode describing that position, but\n * sometimes there does not actually exist one. (for a simple case, the empty\n * string should be interpreted as a text node, but there is no text node in\n * an empty document, but there would be after the first character was typed).\n */\nexport function getLocationInfoForPosition(\n    document: ParsedHtmlDocument, position: SourcePosition): LocationResult {\n  const location =\n      _getLocationInfoForPosition(document.ast, position, document);\n  if (!location) {\n    /** Eh, we're probably in a text node. */\n    return {kind: 'text'};\n  }\n  return location;\n}\n\nfunction _getLocationInfoForPosition(\n    node: parse5.ASTNode,\n    position: SourcePosition,\n    document: ParsedHtmlDocument): undefined|LocationResult {\n  const sourceRange = document.sourceRangeForNode(node);\n  const location = node.__location;\n\n  /**\n   * An HTML5 parser must hallucinate certain nodes, even if they don't exist\n   * in the original source text. e.g. <html> or <body>. So we might have\n   * elements that have no sourceRange (because they don't exist in the text)\n   * but they do have children that do. So we should check those children.\n   */\n  if (!(sourceRange && location)) {\n    return _findLocationInChildren(node, position, document);\n  }\n\n  if (!isPositionInsideRange(position, sourceRange)) {\n    // definitively not in this node or any of its children\n    return;\n  }\n\n  const locationInChildren = _findLocationInChildren(node, position, document);\n  if (locationInChildren) {\n    return locationInChildren;\n  }\n\n  const attributeLocation =\n      getAttributeLocation(node, position, document, location);\n  if (attributeLocation) {\n    return attributeLocation;\n  }\n\n  const startTagRange = document.sourceRangeForStartTag(node);\n  const endTagRange = document.sourceRangeForEndTag(node);\n\n  // If we're in the end tag... we're in the end tag.\n  if (isPositionInsideRange(position, endTagRange, false)) {\n    return {kind: 'endTag', element: node};\n  }\n\n  if (startTagRange && isPositionInsideRange(position, startTagRange, false)) {\n    if (position.line === startTagRange.start.line) {\n      // If the cursor is in the \"<my-elem\" part of the start tag.\n      if (position.column <=\n          startTagRange.start.column + (node.tagName || '').length + 1) {\n        return {kind: 'tagName', element: node};\n      }\n    }\n    // Otherwise we're in the start tag, but not in the tag name or any\n    // particular attribute, but definitely in the attributes section.\n    return {kind: 'attribute', attribute: null, element: node};\n  }\n\n  // The edges of a comment aren't part of the comment.\n  if (parse5.treeAdapters.default.isCommentNode(node) &&\n      isPositionInsideRange(position, sourceRange, false)) {\n    return {kind: 'comment', commentNode: node};\n  }\n\n  if (parse5.treeAdapters.default.isTextNode(node)) {\n    const parent = node.parentNode;\n    if (parent && parent.tagName === 'script') {\n      return {kind: 'scriptTagContents', textNode: node};\n    }\n    if (parent && parent.tagName === 'style') {\n      return {kind: 'styleTagContents', textNode: node};\n    }\n    return {kind: 'text', textNode: node};\n  }\n\n\n  if (isPositionInsideRange(position, sourceRange, false)) {\n    /**\n     * This is tricky. Consider the position inside an empty element, i.e.\n     * here:\n     *    <script>|</script>.\n     *\n     * You can be between the start and end tags, but there won't be a text\n     * node to attach to, but if you started typeing, there would be, so we\n     * want to treat you as though you are.\n     */\n    if (startTagRange && endTagRange &&\n        comparePositionAndRange(position, startTagRange, false) > 0 &&\n        comparePositionAndRange(position, endTagRange, false) < 0) {\n      if (node.tagName === 'script') {\n        return {kind: 'scriptTagContents'};\n      }\n      if (node.tagName === 'style') {\n        return {kind: 'styleTagContents'};\n      }\n      return {kind: 'text'};\n    }\n\n    /**\n     * Ok, we're in this node, we're not in any of its children, but we're not\n     * obviously in any attribute, tagname, start tag, or end tag. We might be\n     * part of a unclosed tag in a mostly empty document. parse5 doesn't give\n     * us much explicit signal in this case, but we can kinda infer it from the\n     * tagName.\n     */\n    if (node.tagName) {\n      if (position.column <=\n          sourceRange.start.column + node.tagName.length + 1) {\n        return {kind: 'tagName', element: node};\n      }\n      return {kind: 'attribute', element: node, attribute: null};\n    }\n  }\n}\n\n\n\nfunction _findLocationInChildren(\n    node: parse5.ASTNode,\n    position: SourcePosition,\n    document: ParsedHtmlDocument) {\n  for (const child of node.childNodes || []) {\n    const result = _getLocationInfoForPosition(child, position, document);\n    if (result) {\n      return result;\n    }\n  }\n  if (node.tagName === 'template') {\n    const content = parse5.treeAdapters.default.getTemplateContent(node);\n    const result = _getLocationInfoForPosition(content, position, document);\n    if (result) {\n      return result;\n    }\n  }\n}\n\nfunction isElementLocationInfo(location: parse5.LocationInfo|\n                               parse5.ElementLocationInfo):\n    location is parse5.ElementLocationInfo {\n  const loc = location as parse5.ElementLocationInfo;\n  return (loc.startTag && loc.endTag) !== undefined;\n}\n\ntype Parse5Location = parse5.LocationInfo|parse5.ElementLocationInfo;\n\n/**\n * If the position is inside of the node's attributes section, return the\n * correct LocationResult.\n */\nfunction getAttributeLocation(\n    node: parse5.ASTNode,\n    position: SourcePosition,\n    document: ParsedHtmlDocument,\n    location: Parse5Location): AttributesSection|AttributeValue|undefined {\n  /**\n   * TODO(rictic): upstream to @types the fact that regular locations (not just\n   * element locations) can have attrs sometimes.\n   */\n  const attrs: parse5.AttributesLocationInfo =\n      (isElementLocationInfo(location) && location.startTag.attrs) ||\n      (location as parse5.StartTagLocationInfo).attrs || {};\n\n  for (const attrName in attrs) {\n    const range = document.sourceRangeForAttribute(node, attrName);\n    if (isPositionInsideRange(position, range)) {\n      if (isPositionInsideRange(\n              position,\n              document.sourceRangeForAttributeValue(node, attrName))) {\n        return {kind: 'attributeValue', attribute: attrName, element: node};\n      }\n      return {kind: 'attribute', attribute: attrName, element: node};\n    }\n  }\n}\n"]}