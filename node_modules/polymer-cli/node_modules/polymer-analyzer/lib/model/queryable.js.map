{"version":3,"sources":["../src/model/queryable.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG","file":"queryable.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as babel from '@babel/types';\nimport {Feature} from './feature';\nimport {Warning} from './warning';\n\n// A map between kind string literal types and their feature types.\nexport interface FeatureKindMap {}\nexport type FeatureKind = keyof FeatureKindMap;\nexport type BaseQueryOptions = {\n  /**\n   * Do not include the containing document or any features from the\n   * containing document; allows querying for features specific to an inline\n   * document and/or its descendents.\n   */\n  excludeBackreferences?: boolean;\n\n  /**\n   * If true then results will include features from outside the package, e.g.\n   * from files in bower_components or node_modules directories.\n   *\n   * Note that even with this option you'll only get results from external files\n   * that are referenced from within the package.\n   */\n  externalPackages?: boolean;\n\n  /**\n   * Do not include any features that are only reachable via paths that include\n   * lazy import edges.\n   */\n  noLazyImports?: boolean;\n\n  /**\n   * If given, the query results will all have the given identifier.\n   *\n   * There identifiers mean different things for different kinds of features.\n   * For example documents are identified by their url, and elements are\n   * identified by their tag and class names.\n   */\n  id?: string;\n}&object;\n\nexport type BaseAnalysisQuery = BaseQueryOptions&{\n  /**\n   * When querying over an Analysis, the results would not be defined if\n   * imports are not considered, so it is legal to specify this parameter,\n   * but it must be true (and it will be ignored in any case).\n   */\n  imported?: true;\n};\n\nexport type BaseDocumentQuery = BaseQueryOptions&{\n  /**\n   * If given, returns any features which are defined by the given statement.\n   * This argument implies `imported: false`.\n   *\n   * See esutil.getStatement for going from a babel-traverse NodePath to the\n   * canonical statment node.\n   */\n  statement?: babel.Statement;\n\n  /**\n   * If true, the query will return results from the document and its\n   * dependencies. Otherwise it will only include results from the document.\n   */\n  imported?: boolean;\n};\n\n\nexport type BaseQuery = BaseQueryOptions&{kind?: string};\nexport type BaseQueryWithKind<K extends FeatureKind> =\n    BaseQueryOptions&{kind: K};\nexport type DocumentQuery = BaseDocumentQuery&{kind?: string};\nexport type DocumentQueryWithKind<K extends FeatureKind> =\n    BaseDocumentQuery&{kind: K};\nexport type AnalysisQuery = BaseAnalysisQuery&{kind?: string};\nexport type AnalysisQueryWithKind<K extends FeatureKind> =\n    BaseAnalysisQuery&{kind: K};\n\n\n/**\n * Represents something like a Document or an Analysis. A container of features\n * and warnings that's queryable in a few different ways.\n */\nexport interface Queryable {\n  getFeatures<K extends FeatureKind>(query: BaseQueryWithKind<K>):\n      Set<FeatureKindMap[K]>;\n  getFeatures(query?: BaseQuery): Set<Feature>;\n\n  getWarnings(options?: BaseQuery): Warning[];\n}\n"]}