{"version":3,"sources":["../src/model/source-range.ts"],"names":[],"mappings":"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","file":"source-range.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {ResolvedUrl} from './url';\n\n/**\n * Describes a range of text within a source file.\n *\n * NOTE: `line` and `column` Position properties are indexed from zero. Consider\n * displaying them to users as one-indexed numbers to match text editor\n * conventions.\n */\nexport interface SourceRange {\n  /* The resolved path to the file. */\n  readonly file: ResolvedUrl;\n  readonly start: SourcePosition;\n  readonly end: SourcePosition;\n}\n\nexport interface SourcePosition {\n  /** The line number, starting from zero. */\n  readonly line: number;\n  /** The column offset within the line, starting from zero. */\n  readonly column: number;\n}\n\nexport interface LocationOffset {\n  /** Zero based line index. */\n  readonly line: number;\n  /** Zero based column index. */\n  readonly col: number;\n  /**\n   * The url of the source file.\n   */\n  readonly filename?: ResolvedUrl;\n}\n\n/**\n * Corrects source ranges based on an offset.\n *\n * Source ranges for inline documents need to be corrected relative to their\n * positions in their containing documents.\n *\n * For example, if a <script> tag appears in the fifth line of its containing\n * document, we need to move all the source ranges inside that script tag down\n * by 5 lines. We also need to correct the column offsets, but only for the\n * first line of the <script> contents.\n */\nexport function correctSourceRange(\n    sourceRange: SourceRange,\n    locationOffset?: LocationOffset|null): SourceRange;\nexport function correctSourceRange(\n    sourceRange: undefined, locationOffset?: LocationOffset|null): undefined;\nexport function correctSourceRange(\n    sourceRange?: SourceRange,\n    locationOffset?: LocationOffset|null): SourceRange|undefined;\nexport function correctSourceRange(\n    sourceRange?: SourceRange,\n    locationOffset?: LocationOffset|null): SourceRange|undefined {\n  if (!locationOffset || !sourceRange) {\n    return sourceRange;\n  }\n  return {\n    file: locationOffset.filename || sourceRange.file,\n    start: correctPosition(sourceRange.start, locationOffset),\n    end: correctPosition(sourceRange.end, locationOffset)\n  };\n}\n\nexport function correctPosition(\n    position: SourcePosition, locationOffset: LocationOffset): SourcePosition {\n  return {\n    line: position.line + locationOffset.line,\n    column: position.column + (position.line === 0 ? locationOffset.col : 0)\n  };\n}\n\nexport function uncorrectSourceRange(\n    sourceRange?: SourceRange,\n    locationOffset?: LocationOffset|null): SourceRange|undefined {\n  if (locationOffset == null || sourceRange == null) {\n    return sourceRange;\n  }\n  return {\n    file: locationOffset.filename || sourceRange.file,\n    start: uncorrectPosition(sourceRange.start, locationOffset),\n    end: uncorrectPosition(sourceRange.end, locationOffset),\n  };\n}\n\nexport function uncorrectPosition(\n    position: SourcePosition, locationOffset: LocationOffset): SourcePosition {\n  const line = position.line - locationOffset.line;\n  return {\n    line: line,\n    column: position.column - (line === 0 ? locationOffset.col : 0)\n  };\n}\n\n/**\n * Returns -1 if source position `a` comes before source position `b`, returns 0\n * if they are the same, returns 1 if `a` comes after `b`.\n */\nexport function comparePosition(a: SourcePosition, b: SourcePosition): number {\n  if (a.line !== b.line) {\n    return a.line < b.line ? -1 : 1;\n  }\n  if (a.column !== b.column) {\n    return a.column < b.column ? -1 : 1;\n  }\n  return 0;\n}\n\n/**\n * If the position is inside the range, returns 0. If it comes before the range,\n * it returns -1. If it comes after the range, it returns 1.\n *\n * TODO(rictic): test this method directly (currently most of its tests are\n *   indirectly, through ast-from-source-position).\n */\nexport function comparePositionAndRange(\n    position: SourcePosition, range: SourceRange, includeEdges?: boolean) {\n  // Usually we want to include the edges of a range as part\n  // of the thing, but sometimes, e.g. for start and end tags,\n  // we'd rather not.\n  if (includeEdges == null) {\n    includeEdges = true;\n  }\n  if (includeEdges == null) {\n    includeEdges = true;\n  }\n  if (position.line < range.start.line) {\n    return -1;\n  }\n  if (position.line > range.end.line) {\n    return 1;\n  }\n  if (position.line === range.start.line) {\n    if (includeEdges) {\n      if (position.column < range.start.column) {\n        return -1;\n      }\n    } else {\n      if (position.column <= range.start.column) {\n        return -1;\n      }\n    }\n  }\n  if (position.line === range.end.line) {\n    if (includeEdges) {\n      if (position.column > range.end.column) {\n        return 1;\n      }\n    } else {\n      if (position.column >= range.end.column) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nexport function isPositionInsideRange(\n    position: SourcePosition,\n    range: SourceRange|undefined,\n    includeEdges?: boolean) {\n  if (!range) {\n    return false;\n  }\n  return comparePositionAndRange(position, range, includeEdges) === 0;\n}\n"]}