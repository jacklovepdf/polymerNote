{"version":3,"sources":["../src/model/reference.ts"],"names":[],"mappings":"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","file":"reference.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {NodePath} from '@babel/traverse';\nimport * as babel from '@babel/types';\nimport * as util from 'util';\n\nimport {AstNodeWithLanguage} from '..';\nimport * as esutil from '../javascript/esutil';\nimport {Annotation} from '../javascript/jsdoc';\n\nimport {Result} from './analysis';\nimport {Document} from './document';\nimport {Feature, ScannedFeature} from './feature';\nimport {FeatureKindMap} from './queryable';\nimport {Resolvable} from './resolvable';\nimport {SourceRange} from './source-range';\nimport {Severity, Warning} from './warning';\n\n\n/**\n * A reference to another feature by identifier.\n */\nexport class ScannedReference<K extends keyof FeatureKindMap> extends\n    ScannedFeature implements Resolvable {\n  readonly identifier: string;\n  readonly kind: K;\n  readonly sourceRange: SourceRange|undefined;\n  readonly astPath: NodePath;\n  readonly astNode: AstNodeWithLanguage|undefined;\n\n  constructor(\n      kind: K, identifier: string, sourceRange: SourceRange|undefined,\n      astNode: AstNodeWithLanguage|undefined, astPath: NodePath,\n      description?: string, jsdoc?: Annotation, warnings?: Warning[]) {\n    super(sourceRange, astNode, description, jsdoc, warnings);\n    this.kind = kind;\n    this.astNode = astNode;\n    this.astPath = astPath;\n    this.sourceRange = sourceRange;\n    this.identifier = identifier;\n  }\n\n  resolve(document: Document): Reference<FeatureKindMap[K]> {\n    return this.resolveWithKind(document, this.kind);\n  }\n\n  // Leaving this as a public method, in case we want to use a more\n  // specific kind (e.g. resolve a PolymerElement rather than just a Class).\n  resolveWithKind<DK extends keyof FeatureKindMap>(\n      document: Document, kind: DK): Reference<FeatureKindMap[DK]> {\n    let feature: undefined|FeatureKindMap[DK];\n    const warnings = [...this.warnings];\n\n    const scopedResult =\n        resolveScopedAt(this.astPath, this.identifier, document, kind);\n    if (scopedResult.successful) {\n      feature = scopedResult.value;\n    } else {\n      if (scopedResult.error !== undefined) {\n        warnings.push(scopedResult.error);\n      }\n    }\n    // TODO(https://github.com/Polymer/polymer-analyzer/issues/917):\n    //     Don't look things up in the global map if the scoped binding\n    //     resolves.\n    if (feature === undefined) {\n      // We didn't find it by doing principled scope-based analysis. Let's try\n      // looking it up in our big global map!\n      const features = document.getFeatures(\n          {imported: true, externalPackages: true, kind, id: this.identifier});\n      if (this.sourceRange) {\n        if (features.size === 0) {\n          let message = `Could not resolve reference to ${this.kind}`;\n          if (kind === 'behavior') {\n            message += `. Is it annotated with @polymerBehavior?`;\n          }\n          warnings.push(new Warning({\n            code: 'could-not-resolve-reference',\n            sourceRange: this.sourceRange,\n            message,\n            parsedDocument: document.parsedDocument,\n            severity: Severity.WARNING\n          }));\n        } else if (features.size > 1) {\n          warnings.push(new Warning({\n            code: 'multiple-global-declarations',\n            sourceRange: this.sourceRange,\n            message: `Multiple global declarations of ${\n                this.kind} with identifier ${this.identifier}`,\n            parsedDocument: document.parsedDocument,\n            severity: Severity.WARNING\n          }));\n        }\n      }\n      [feature] = features;\n    }\n    return new Reference<FeatureKindMap[K]>(\n        this.identifier, this.sourceRange, this.astNode, feature, warnings);\n  }\n}\n\nfunction resolveScopedAt<K extends keyof FeatureKindMap>(\n    path: NodePath, identifier: string, document: Document, kind: K):\n    Result<FeatureKindMap[K], Warning|undefined> {\n  // TODO(https://github.com/Polymer/polymer-analyzer/issues/919): we need to\n  //     emit warnings from this function.\n\n  // Handle all kinds of imports except namespace imports (see below for them).\n  if (isSomeKindOfImport(path)) {\n    const exportedIdentifier = getExportedIdentifier(path.node, identifier);\n    return resolveThroughImport(path, exportedIdentifier, document, kind);\n  }\n  const statement = esutil.getCanonicalStatement(path);\n  if (statement === undefined) {\n    return {successful: false, error: undefined};\n  }\n  const features = document.getFeatures({kind, id: identifier, statement});\n  if (features.size > 1) {\n    // TODO(rictic): narrow down by identifier? warn?\n    return {successful: false, error: undefined};\n  }\n  const [feature] = features;\n  if (feature !== undefined) {\n    return {successful: true, value: feature};\n  }\n  // Handle namespace imports. e.g.\n  //     import * as foo from 'foo-library'; class X extends foo.Bar {}\n  const hasASingleDotInName = /^[^\\.]+\\.[^\\.]+$/;\n  if (hasASingleDotInName.test(identifier)) {\n    const [namespace, name] = identifier.split('.');\n    const namespaceBinding = path.scope.getBinding(namespace);\n    if (namespaceBinding !== undefined) {\n      const node = namespaceBinding.path.node;\n      if (babel.isImportNamespaceSpecifier(node)) {\n        return resolveThroughImport(\n            namespaceBinding.path, name, document, kind);\n      }\n    }\n  }\n  const binding = path.scope.getBinding(identifier);\n  if (binding === undefined || binding.path.node === path.node) {\n    return {successful: false, error: undefined};\n  }\n  return resolveScopedAt(binding.path, identifier, document, kind);\n}\n\nfunction resolveThroughImport<K extends keyof FeatureKindMap>(\n    path: NodePath, exportedAs: string, document: Document, kind: K):\n    Result<FeatureKindMap[K], Warning|undefined> {\n  const statement = esutil.getCanonicalStatement(path);\n  if (statement === undefined) {\n    throw new Error(`Internal error, could not get statement for node of type ${\n        path.node.type}`);\n  }\n  const [import_] = document.getFeatures({kind: 'import', statement});\n  if (import_ === undefined || import_.document === undefined) {\n    // Import failed, maybe it could not be loaded.\n    return {successful: false, error: undefined};\n  }\n  // If it was renamed like `import {foo as bar} from 'baz';` then\n  // node.imported.name will be `foo`\n  const [export_] =\n      import_.document.getFeatures({kind: 'export', id: exportedAs});\n  if (export_ === undefined) {\n    // That symbol was not exported from the other file.\n    return {successful: false, error: undefined};\n  }\n  return resolveScopedAt(\n      export_.astNodePath, exportedAs, import_.document, kind);\n}\n\n// We handle ImportNamespaceSpecifiers separately, as resolving their bindings\n// is slightly tricky.\ntype ImportIndicator = babel.ImportDefaultSpecifier|babel.ImportSpecifier|\n                       babel.ExportNamedDeclaration|babel.ExportAllDeclaration;\nfunction isSomeKindOfImport(path: NodePath): path is NodePath<ImportIndicator> {\n  const node = path.node;\n  return babel.isImportSpecifier(node) ||\n      babel.isImportDefaultSpecifier(node) ||\n      (babel.isExportNamedDeclaration(node) && node.source != null) ||\n      (babel.isExportAllDeclaration(node));\n}\n\nfunction getExportedIdentifier(node: ImportIndicator, localIdentifier: string) {\n  switch (node.type) {\n    case 'ImportDefaultSpecifier':\n      return 'default';\n    case 'ExportNamedDeclaration':\n      for (const specifier of node.specifiers) {\n        if (specifier.exported.name === localIdentifier) {\n          return specifier.local.name;\n        }\n      }\n      throw new Error(`Internal error: could not find import specifier for '${\n          localIdentifier}'. Please report this bug.`);\n    case 'ExportAllDeclaration':\n      // Can't rename through an export all, the name we're looking for in\n      // this file is the same name in the next file.\n      return localIdentifier;\n    case 'ImportSpecifier':\n      return node.imported.name;\n  }\n  return assertNever(node);\n}\n\nfunction assertNever(never: never): never {\n  throw new Error(`Unexpected ast node: ${util.inspect(never)}`);\n}\n\ndeclare module './queryable' {\n  interface FeatureKindMap {\n    'reference': Reference<Feature>;\n  }\n}\n\nconst referenceSet: ReadonlySet<'reference'> =\n    new Set<'reference'>(['reference']);\nconst emptySet: ReadonlySet<string> = new Set();\n\n/**\n * A reference to another feature by identifier.\n */\nexport class Reference<F extends Feature> implements Feature {\n  readonly kinds = referenceSet;\n  readonly identifiers = emptySet;\n  readonly identifier: string;\n  readonly sourceRange: SourceRange|undefined;\n  readonly astNode: AstNodeWithLanguage|undefined;\n  readonly feature: F|undefined;\n  readonly warnings: ReadonlyArray<Warning>;\n\n  constructor(\n      identifier: string, sourceRange: SourceRange|undefined,\n      astNode: AstNodeWithLanguage|undefined, feature: F|undefined,\n      warnings: ReadonlyArray<Warning>) {\n    this.identifier = identifier;\n    this.sourceRange = sourceRange;\n    this.astNode = astNode;\n    this.warnings = warnings;\n    this.feature = feature;\n  }\n}\n"]}