{"version":3,"sources":["../src/model/analysis.ts"],"names":[],"mappings":"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","file":"analysis.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {SourceRange} from '../analysis-format/analysis-format';\nimport {AnalysisContext} from '../core/analysis-context';\nimport {addAll} from '../core/utils';\nimport {PackageRelativeUrl} from '../index';\n\nimport {Document} from './document';\nimport {Feature} from './feature';\nimport {ImmutableMap, ImmutableSet} from './immutable';\nimport {AnalysisQuery as Query, AnalysisQueryWithKind as QueryWithKind, DocumentQuery, FeatureKind, FeatureKindMap, Queryable} from './queryable';\nimport {isPositionInsideRange} from './source-range';\nimport {ResolvedUrl} from './url';\nimport {Warning} from './warning';\n\n\n/**\n * Represents the result of a computation that may fail.\n *\n * This lets us represent errors in a type-safe way, as well as\n * in a way that makes it clear to the caller that the computation\n * may fail.\n */\nexport type Result<T, E> = {\n  successful: true,\n  value: T,\n}|{\n  successful: false,\n  error: E,\n};\n\n// A regexp that matches paths to external code.\n// TODO(rictic): Make this part of the URL Resolver.\n//     https://github.com/Polymer/polymer-analyzer/issues/803\n// Note that we will match any directory name prefixed by `bower_components` or\n// `node_modules` in order to ignore `polymer install`'s variants, which look\n// like bower_components-foo\nconst MATCHES_EXTERNAL = /(^|\\/)(bower_components|node_modules($|\\/))/;\n\n/**\n * Represents a queryable interface over all documents in a package/project.\n *\n * Results of queries will include results from all documents in the package, as\n * well as from external dependencies that are transitively imported by\n * documents in the package.\n */\nexport class Analysis implements Queryable {\n  private readonly _results: ImmutableMap<ResolvedUrl, Document|Warning>;\n  private readonly _searchRoots: ImmutableSet<Document>;\n\n  static isExternal(path: string) {\n    return MATCHES_EXTERNAL.test(path);\n  }\n\n  constructor(\n      results: Map<ResolvedUrl, Document|Warning>,\n      private readonly context: AnalysisContext) {\n    workAroundDuplicateJsScriptsBecauseOfHtmlScriptTags(results);\n\n    this._results = results;\n    const documents =\n        Array.from(results.values()).filter((r) => r instanceof Document) as\n        Document[];\n    const potentialRoots = new Set(documents);\n\n    // We trim down the set of documents as a performance optimization. We only\n    // need a set of documents such that all other documents we're interested in\n    // can be reached from them. That way we'll do less duplicate work when we\n    // query over all documents.\n    for (const doc of potentialRoots) {\n      for (const imprt of doc.getFeatures({kind: 'import', imported: true})) {\n        // When there's cycles we can keep any element of the cycle, so why not\n        // this one.\n        if (imprt.document !== undefined && imprt.document !== doc) {\n          potentialRoots.delete(imprt.document);\n        }\n      }\n    }\n    this._searchRoots = potentialRoots;\n  }\n\n  getDocument(packageRelativeUrl: string): Result<Document, Warning|undefined> {\n    const url =\n        this.context.resolver.resolve(packageRelativeUrl as PackageRelativeUrl);\n    if (url === undefined) {\n      return {successful: false, error: undefined};\n    }\n    const result = this._results.get(url);\n    if (result != null) {\n      if (result instanceof Document) {\n        return {successful: true, value: result};\n      } else {\n        return {successful: false, error: result};\n      }\n    }\n    const documents =\n        Array\n            .from(this.getFeatures(\n                {kind: 'document', id: url, externalPackages: true}))\n            .filter((d) => !d.isInline);\n    if (documents.length !== 1) {\n      return {successful: false, error: undefined};\n    }\n    return {successful: true, value: documents[0]!};\n  }\n\n  /**\n   * Get features in the package.\n   *\n   * Be default this includes features in all documents inside the package,\n   * but you can specify whether to also include features that are outside the\n   * package reachable by documents inside. See the documentation for Query for\n   * more details.\n   *\n   * You can also narrow by feature kind and identifier.\n   */\n  getFeatures<K extends FeatureKind>(query: QueryWithKind<K>):\n      Set<FeatureKindMap[K]>;\n  getFeatures(query?: Query): Set<Feature>;\n  getFeatures(query: Query = {}): Set<Feature> {\n    const result = new Set();\n    const docQuery = this._getDocumentQuery(query);\n    for (const doc of this._searchRoots) {\n      addAll(result, doc.getFeatures(docQuery));\n    }\n    return result;\n  }\n\n  /**\n   * Get all warnings in the project.\n   */\n  getWarnings(options?: Query): Warning[] {\n    const warnings = Array.from(this._results.values())\n                         .filter((r) => !(r instanceof Document)) as Warning[];\n    const result = new Set(warnings);\n    const docQuery = this._getDocumentQuery(options);\n    for (const doc of this._searchRoots) {\n      addAll(result, new Set(doc.getWarnings(docQuery)));\n    }\n    return Array.from(result);\n  }\n\n  /**\n   * Potentially narrow down the document that contains the sourceRange.\n   * For example, if a source range is inside a inlineDocument, this function\n   * will narrow down the document to the most specific inline document.\n   *\n   * @param sourceRange Source range to search for in a document\n   */\n  getDocumentContaining(sourceRange: SourceRange|undefined): Document\n      |undefined {\n    if (!sourceRange) {\n      return undefined;\n    }\n    let mostSpecificDocument: undefined|Document = undefined;\n    const [outerDocument] =\n        this.getFeatures({kind: 'document', id: sourceRange.file});\n    if (!outerDocument) {\n      return undefined;\n    }\n    for (const doc of outerDocument.getFeatures({kind: 'document'})) {\n      if (isPositionInsideRange(sourceRange.start, doc.sourceRange)) {\n        if (!mostSpecificDocument ||\n            isPositionInsideRange(\n                doc.sourceRange!.start, mostSpecificDocument.sourceRange)) {\n          mostSpecificDocument = doc;\n        }\n      }\n    }\n    return mostSpecificDocument;\n  }\n\n  private _getDocumentQuery(query: Query = {}): DocumentQuery {\n    return {\n      kind: query.kind,\n      id: query.id,\n      externalPackages: query.externalPackages,\n      imported: true,\n      excludeBackreferences: query.excludeBackreferences,\n      noLazyImports: query.noLazyImports,\n    };\n  }\n}\n\n/**\n * So, we have this really terrible hack, whereby we generate a new Document for\n * a js file when it is referenced in an external script tag in an HTML\n * document. We do this so that we can inject an artificial import of the HTML\n * document into the js document, so that the HTML document's dependencies are\n * also dependencies of the js document.\n *\n * This works, but we want to eliminate these duplicate JS Documents from the\n * Analysis before the user sees them.\n *\n * https://github.com/Polymer/polymer-analyzer/issues/615 tracks a better\n * solution for this issue\n */\nfunction workAroundDuplicateJsScriptsBecauseOfHtmlScriptTags(\n    results: Map<string, Document|Warning>) {\n  const documents =\n      Array.from(results.values()).filter((r) => r instanceof Document) as\n      Document[];\n  // TODO(rictic): handle JS imported via script src from HTML better than\n  //     this.\n  const potentialDuplicates =\n      new Set(documents.filter((r) => r.kinds.has('js-document')));\n  const canonicalOverrides = new Set<Document>();\n  for (const doc of documents) {\n    if (potentialDuplicates.has(doc)) {\n      continue;\n    }\n    for (const potentialDupe of potentialDuplicates) {\n      const potentialCanonicalDocs = doc.getFeatures(\n          {kind: 'js-document', id: potentialDupe.url, imported: true});\n      for (const potentialCanonicalDoc of potentialCanonicalDocs) {\n        if (!potentialCanonicalDoc.isInline) {\n          canonicalOverrides.add(potentialCanonicalDoc);\n        }\n      }\n    }\n  }\n\n  for (const canonicalDoc of canonicalOverrides) {\n    results.set(canonicalDoc.url, canonicalDoc);\n  }\n}\n"]}