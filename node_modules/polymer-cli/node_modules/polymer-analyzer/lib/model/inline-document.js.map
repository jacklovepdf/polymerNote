{"version":3,"sources":["../src/model/inline-document.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;AAGH,4CAA4C;AAG5C,6BAA6B;AAG7B,yDAAqE;AAErE,6CAA6C;AAE7C,yCAAqD;AACrD,qEAA+D;AAE/D,2CAA4C;AAiC5C;;;;;GAKG;AACH;IAgBE,YACI,IAAY,EAAE,QAAgB,EAAE,cAA8B,EAC9D,eAAuB,EAAE,WAAwB,EACjD,OAA4B;QAPvB,aAAQ,GAAc,EAAE,CAAC;QAQhC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAED,OAAO,CAAC,QAAkB;QACxB,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;YACzB,sCAAsC;YACtC,OAAO;SACR;QACD,MAAM,cAAc,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;QAC1E,cAAc,CAAC,OAAO,EAAE,CAAC;QACzB,OAAO,cAAc,CAAC;IACxB,CAAC;CACF;AArCD,sDAqCC;AAOD,oBAA4B,SAAQ,mBAAQ;IAC1C,YAAY,IAAqB,EAAE,iBAA2B;QAC5D,KAAK,CAAC,IAAI,EAAE,iBAAiB,CAAC,gBAAgB,CAAC,CAAC;QAChD,2BAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;QACnD,IAAI,CAAC,WAAW,CAAC,IAAI,8CAAqB,CAAC,iBAAiB,CAAC,CAAC,CAAC;IACjE,CAAC;CACF;AAND,wCAMC;AAED,gCAAuC,IAAa;IAClD,MAAM,WAAW,GAAG,sBAAsB,CAAC,IAAI,CAAC,CAAC;IACjD,IAAI,CAAC,WAAW,EAAE;QAChB,OAAO;KACR;IACD,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;IACjD,IAAI,CAAC,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;QACxC,OAAO;KACR;IACD,OAAO,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;AACxC,CAAC;AAVD,wDAUC;AAED,gCAAgC,IAAa;IAC3C,MAAM,YAAY,GAAG,mBAAmB,CAAC,IAAI,CAAC,CAAC;IAC/C,MAAM,mBAAmB,GAAG,uBAAuB,CAAC,YAAY,CAAC,CAAC;IAClE,MAAM,CAAC,yBAAyB,CAAC,GAAG,mBAAmB,CAAC;IACxD,IAAI,CAAC,yBAAyB,EAAE;QAC9B,OAAO,CAAE,yBAAyB;KACnC;IACD,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,yBAAyB,CAAC,EAAE;QAClD,OAAO,CAAE,gCAAgC;KAC1C;IACD,OAAO,yBAAyB,CAAC;AACnC,CAAC;AAED;;;GAGG;AACH,QAAQ,CAAC,yBACmB,QAA2B;IACrD,KAAK,MAAM,IAAI,IAAI,QAAQ,EAAE;QAC3B,qEAAqE;QACrE,oDAAoD;QACpD,IAAI,0BAAU,CAAC,IAAI,CAAC,EAAE;YACpB,SAAS;SACV;QACD,6CAA6C;QAC7C,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;YACzB,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC;YAC9C,IAAI,IAAI,KAAK,EAAE,EAAE;gBACf,SAAS;aACV;SACF;QACD,MAAM,IAAI,CAAC;KACZ;AACH,CAAC;AAED;;;;;;;;;;;;;;;GAeG;AACH,QAAQ,CAAC,qBAAqB,IAAa;IACzC,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC;IAC/B,IAAI,MAAM,EAAE;QACV,MAAM,QAAQ,GAAG,MAAM,CAAC,UAAW,CAAC;QACpC,KAAK,IAAI,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YACpD,MAAM,WAAW,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAChC,IAAI,0BAAU,CAAC,WAAW,CAAC,EAAE;gBAC3B,IAAI,WAAW,CAAC,UAAU,EAAE;oBAC1B,KAAK,CAAC,CAAC,WAAW,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;iBAC5C;aACF;iBAAM;gBACL,MAAM,WAAW,CAAC;aACnB;SACF;QACD,IAAI,0BAAU,CAAC,MAAM,CAAC,EAAE;YACtB,KAAK,CAAC,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;SACpC;KACF;AACH,CAAC;AAED,QAAQ,CAAC,aAAgB,GAAa;IACpC,KAAK,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;QACxC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;KACd;AACH,CAAC;AAED,+CACI,IAAa,EAAE,cAAkC;IACnD,MAAM,WAAW,GAAG,cAAc,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;IAChE,IAAI,CAAC,WAAW,EAAE;QAChB,MAAM,IAAI,KAAK,CACX,qDAAqD;YACrD,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KAC9B;IACD,OAAO,EAAC,IAAI,EAAE,WAAW,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,WAAW,CAAC,GAAG,CAAC,MAAM,EAAC,CAAC;AACnE,CAAC;AATD,sFASC","file":"inline-document.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as babel from '@babel/types';\nimport * as dom5 from 'dom5/lib/index-next';\nimport {ASTNode} from 'parse5';\nimport * as shady from 'shady-css-parser';\nimport * as util from 'util';\n\nimport {ParsedCssDocument} from '..';\nimport {isFakeNode, ParsedHtmlDocument} from '../html/html-document';\nimport {JavaScriptDocument} from '../javascript/javascript-document';\nimport * as jsdoc from '../javascript/jsdoc';\n\nimport {Document, ScannedDocument} from './document';\nimport {DocumentBackreference} from './document-backreference';\nimport {ScannedFeature} from './feature';\nimport {unsafeAsMutable} from './immutable';\nimport {Resolvable} from './resolvable';\nimport {LocationOffset, SourceRange} from './source-range';\nimport {ResolvedUrl} from './url';\nimport {Warning} from './warning';\n\nexport interface InlineDocInfo {\n  astNode?: AstNodeWithLanguage;\n  locationOffset?: LocationOffset;\n  baseUrl?: ResolvedUrl;\n}\n\nexport interface HtmlAstNode {\n  language: 'html';\n  node: dom5.Node;\n  containingDocument: ParsedHtmlDocument;\n}\n\n\nexport interface JsAstNode<N extends babel.Node = babel.Node> {\n  language: 'js';\n  node: N;\n  containingDocument: JavaScriptDocument;\n}\n\nexport interface CssAstNode {\n  language: 'css';\n  node: shady.Node;\n  containingDocument: ParsedCssDocument;\n}\n\nexport type AstNodeWithLanguage = HtmlAstNode|JsAstNode|CssAstNode;\n\n/**\n * Represents an inline document, usually a <script> or <style> tag in an HTML\n * document.\n *\n * @template N The AST node type\n */\nexport class ScannedInlineDocument implements ScannedFeature, Resolvable {\n  readonly type: 'html'|'js'|'css'|/* etc */ string;\n\n  readonly contents: string;\n\n  /** The location offset of this document within the containing document. */\n  readonly locationOffset: LocationOffset;\n  readonly attachedComment?: string;\n\n  scannedDocument?: ScannedDocument;\n\n  readonly sourceRange: SourceRange;\n  readonly warnings: Warning[] = [];\n\n  readonly astNode: AstNodeWithLanguage;\n\n  constructor(\n      type: string, contents: string, locationOffset: LocationOffset,\n      attachedComment: string, sourceRange: SourceRange,\n      astNode: AstNodeWithLanguage) {\n    this.type = type;\n    this.contents = contents;\n    this.locationOffset = locationOffset;\n    this.attachedComment = attachedComment;\n    this.sourceRange = sourceRange;\n    this.astNode = astNode;\n  }\n\n  resolve(document: Document): Document|undefined {\n    if (!this.scannedDocument) {\n      // Parse error on the inline document.\n      return;\n    }\n    const inlineDocument = new InlineDocument(this.scannedDocument, document);\n    inlineDocument.resolve();\n    return inlineDocument;\n  }\n}\n\ndeclare module './queryable' {\n  interface FeatureKindMap {\n    'inline-document': InlineDocument;\n  }\n}\nexport class InlineDocument extends Document {\n  constructor(base: ScannedDocument, containerDocument: Document) {\n    super(base, containerDocument._analysisContext);\n    unsafeAsMutable(this.kinds).add('inline-document');\n    this._addFeature(new DocumentBackreference(containerDocument));\n  }\n}\n\nexport function getAttachedCommentText(node: ASTNode): string|undefined {\n  const commentNode = getAttachedCommentNode(node);\n  if (!commentNode) {\n    return;\n  }\n  const comment = dom5.getTextContent(commentNode);\n  if (!comment || /@license/.test(comment)) {\n    return;\n  }\n  return jsdoc.unindent(comment).trim();\n}\n\nfunction getAttachedCommentNode(node: ASTNode): ASTNode|undefined {\n  const predecessors = getPreviousSiblings(node);\n  const visiblePredecessors = filterOutInvisibleNodes(predecessors);\n  const [closestVisiblePredecessor] = visiblePredecessors;\n  if (!closestVisiblePredecessor) {\n    return;  // no predecessors at all\n  }\n  if (!dom5.isCommentNode(closestVisiblePredecessor)) {\n    return;  // attached node isn't a comment\n  }\n  return closestVisiblePredecessor;\n}\n\n/**\n * Filter out nodes that are just whitespace, or aren't present in the original\n * source text of the file.\n */\nfunction*\n    filterOutInvisibleNodes(nodeIter: Iterable<ASTNode>): Iterable<ASTNode> {\n  for (const node of nodeIter) {\n    // Ignore nodes that aren't present in the original text of the file,\n    // like parser-hallucinated <head> and <body> nodes.\n    if (isFakeNode(node)) {\n      continue;\n    }\n    // Ignore text nodes that are just whitespace\n    if (dom5.isTextNode(node)) {\n      const text = dom5.getTextContent(node).trim();\n      if (text === '') {\n        continue;\n      }\n    }\n    yield node;\n  }\n}\n\n/**\n * An iterable over siblings that come before the given node.\n *\n * Note that this method gives siblings from the author's point of view, not\n * the pedantic parser's point of view, so we need to traverse some fake\n * nodes. e.g. consider this document\n *\n *     <link rel=\"import\" href=\"foo.html\">\n *     <dom-module></dom-module>\n *\n * For this method's purposes, these nodes are siblings, but in the AST\n * they're actually cousins! The link is in a hallucinated <head> node, and\n * the dom-module is in a hallucinated <body> node, so to get to the link we\n * need to go up to the body, then back to the head, then back down, but\n * only if the head and body are hallucinated.\n */\nfunction* getPreviousSiblings(node: ASTNode): Iterable<ASTNode> {\n  const parent = node.parentNode;\n  if (parent) {\n    const siblings = parent.childNodes!;\n    for (let i = siblings.indexOf(node) - 1; i >= 0; i--) {\n      const predecessor = siblings[i];\n      if (isFakeNode(predecessor)) {\n        if (predecessor.childNodes) {\n          yield* iterReverse(predecessor.childNodes);\n        }\n      } else {\n        yield predecessor;\n      }\n    }\n    if (isFakeNode(parent)) {\n      yield* getPreviousSiblings(parent);\n    }\n  }\n}\n\nfunction* iterReverse<V>(arr: Array<V>): Iterable<V> {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    yield arr[i];\n  }\n}\n\nexport function getLocationOffsetOfStartOfTextContent(\n    node: ASTNode, parsedDocument: ParsedHtmlDocument): LocationOffset {\n  const sourceRange = parsedDocument.sourceRangeForStartTag(node);\n  if (!sourceRange) {\n    throw new Error(\n        `Couldn't extract a location offset from HTML node: ` +\n        `${util.inspect(node)}`);\n  }\n  return {line: sourceRange.end.line, col: sourceRange.end.column};\n}\n"]}