{"version":3,"sources":["../src/polymer/declaration-property-handlers.ts"],"names":[],"mappings":"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","file":"declaration-property-handlers.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {NodePath} from '@babel/traverse';\nimport * as babel from '@babel/types';\n\nimport * as astValue from '../javascript/ast-value';\nimport {getSimpleObjectProperties} from '../javascript/esutil';\nimport {JavaScriptDocument} from '../javascript/javascript-document';\nimport {Result} from '../model/analysis';\nimport {ScannedReference, Severity, Warning} from '../model/model';\n\nimport {analyzeProperties} from './analyze-properties';\nimport {parseExpressionInJsStringLiteral} from './expression-scanner';\nimport {Observer, ScannedPolymerElement} from './polymer-element';\n\nexport type BehaviorReferenceOrWarning = {\n  kind: 'warning',\n  warning: Warning\n}|{kind: 'behaviorReference', reference: ScannedReference<'behavior'>};\n\nexport function getBehaviorReference(\n    argNode: babel.Node, document: JavaScriptDocument, path: NodePath):\n    Result<ScannedReference<'behavior'>, Warning> {\n  const behaviorName = astValue.getIdentifierName(argNode);\n  if (!behaviorName) {\n    return {\n      successful: false,\n      error: new Warning({\n        code: 'could-not-determine-behavior-name',\n        message: `Could not determine behavior name from expression of type ` +\n            `${argNode.type}`,\n        severity: Severity.WARNING,\n        sourceRange: document.sourceRangeForNode(argNode)!,\n        parsedDocument: document\n      })\n    };\n  }\n  return {\n    successful: true,\n    value: new ScannedReference(\n        'behavior',\n        behaviorName,\n        document.sourceRangeForNode(argNode)!,\n        {language: 'js', node: argNode, containingDocument: document},\n        path)\n  };\n}\n\nexport type PropertyHandlers = {\n  [key: string]: (node: babel.Node) => void\n};\n\n\n/**\n * Returns an object containing functions that will annotate `declaration` with\n * the polymer-specific meaning of the value nodes for the named properties.\n */\nexport function declarationPropertyHandlers(\n    declaration: ScannedPolymerElement,\n    document: JavaScriptDocument,\n    path: NodePath): PropertyHandlers {\n  return {\n    is(node: babel.Node) {\n      if (babel.isLiteral(node)) {\n        declaration.tagName = '' + astValue.expressionToValue(node);\n      }\n    },\n    properties(node: babel.Node) {\n      for (const prop of analyzeProperties(node, document)) {\n        declaration.addProperty(prop);\n      }\n    },\n    behaviors(node: babel.Node) {\n      if (!babel.isArrayExpression(node)) {\n        return;\n      }\n      for (const element of node.elements) {\n        const result = getBehaviorReference(element, document, path);\n        if (result.successful === false) {\n          declaration.warnings.push(result.error);\n        } else {\n          declaration.behaviorAssignments.push(result.value);\n        }\n      }\n    },\n    observers(node: babel.Node) {\n      const observers = extractObservers(node, document);\n      if (!observers) {\n        return;\n      }\n      declaration.warnings = declaration.warnings.concat(observers.warnings);\n      declaration.observers = declaration.observers.concat(observers.observers);\n    },\n    listeners(node: babel.Node) {\n      if (!babel.isObjectExpression(node)) {\n        declaration.warnings.push(new Warning({\n          code: 'invalid-listeners-declaration',\n          message: '`listeners` property should be an object expression',\n          severity: Severity.WARNING,\n          sourceRange: document.sourceRangeForNode(node)!,\n          parsedDocument: document\n        }));\n        return;\n      }\n\n      for (const p of getSimpleObjectProperties(node)) {\n        const evtName =\n            babel.isLiteral(p.key) && astValue.expressionToValue(p.key) ||\n            babel.isIdentifier(p.key) && p.key.name;\n        const handler =\n            !babel.isLiteral(p.value) || astValue.expressionToValue(p.value);\n\n        if (typeof evtName !== 'string' || typeof handler !== 'string') {\n          // TODO (maklesoft): Notifiy the user somehow that a listener entry\n          // was not extracted\n          // because the event or handler namecould not be statically analyzed.\n          // E.g. add a low-severity\n          // warning once opting out of rules is supported.\n          continue;\n        }\n\n        declaration.listeners.push({event: evtName, handler: handler});\n      }\n    }\n  };\n}\n\n\nexport function extractObservers(\n    observersArray: babel.Node, document: JavaScriptDocument): undefined|\n    {observers: Observer[], warnings: Warning[]} {\n  if (!babel.isArrayExpression(observersArray)) {\n    return;\n  }\n  let warnings: Warning[] = [];\n  const observers = [];\n  for (const element of observersArray.elements) {\n    let v = astValue.expressionToValue(element);\n    if (v === undefined) {\n      v = astValue.CANT_CONVERT;\n    }\n    const parseResult =\n        parseExpressionInJsStringLiteral(document, element, 'callExpression');\n    warnings = warnings.concat(parseResult.warnings);\n    observers.push({\n      javascriptNode: element,\n      expression: v,\n      parsedExpression: parseResult.databinding\n    });\n  }\n  return {observers, warnings};\n}\n"]}