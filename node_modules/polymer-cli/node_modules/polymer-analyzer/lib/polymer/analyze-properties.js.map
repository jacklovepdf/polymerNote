{"version":3,"sources":["../src/polymer/analyze-properties.ts"],"names":[],"mappings":"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","file":"analyze-properties.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as babel from '@babel/types';\nimport * as doctrine from 'doctrine';\n\nimport * as astValue from '../javascript/ast-value';\nimport * as esutil from '../javascript/esutil';\nimport {JavaScriptDocument} from '../javascript/javascript-document';\nimport * as jsdoc from '../javascript/jsdoc';\nimport {Severity, Warning} from '../model/model';\n\nimport {parseExpressionInJsStringLiteral} from './expression-scanner';\nimport {toScannedPolymerProperty} from './js-utils';\nimport {ScannedPolymerProperty} from './polymer-element';\n\n/**\n * Given a properties block (i.e. object literal), parses and extracts the\n * properties declared therein.\n *\n * @param node The value of the `properties` key in a Polymer 1 declaration, or\n *     the return value of the `properties` static getter in a Polymer 2 class.\n * @param document The containing JS document.\n */\nexport function analyzeProperties(\n    node: babel.Node, document: JavaScriptDocument): ScannedPolymerProperty[] {\n  const analyzedProps: ScannedPolymerProperty[] = [];\n\n  if (!babel.isObjectExpression(node)) {\n    return analyzedProps;\n  }\n\n  for (const property of esutil.getSimpleObjectProperties(node)) {\n    const prop = toScannedPolymerProperty(\n        property, document.sourceRangeForNode(property)!, document);\n    if (prop === undefined) {\n      continue;\n    }\n\n    // toScannedPolymerProperty does the wrong thing for us with type. We want\n    // type to be undefined unless there's a positive signal for the type.\n    // toScannedPolymerProperty will give Object because it infers based on the\n    // property declaration.\n    prop.type = undefined;\n    const typeTag = jsdoc.getTag(prop.jsdoc, 'type');\n    if (typeTag) {\n      prop.type =\n          typeTag.type ? doctrine.type.stringify(typeTag.type) : undefined;\n    }\n    prop.published = true;\n\n    let isComputed = false;\n\n    const value = property.value;\n    if (babel.isIdentifier(value)) {\n      // Polymer supports this simple syntax, where only the attribute\n      // deserializer is specified.\n      prop.attributeType = value.name;\n\n    } else if (!babel.isObjectExpression(value)) {\n      continue;\n\n    } else {\n      /**\n       * Parse the expression inside a property object block. e.g.\n       * property: {\n       *   key: {\n       *     type: String,\n       *     notify: true,\n       *     value: -1,\n       *     readOnly: true,\n       *     reflectToAttribute: true\n       *   }\n       * }\n       */\n      for (const propertyArg of esutil.getSimpleObjectProperties(value)) {\n        const propertyKey = esutil.getPropertyName(propertyArg);\n\n        switch (propertyKey) {\n          case 'type':\n            prop.attributeType = astValue.getIdentifierName(propertyArg.value);\n            if (prop.attributeType === undefined && prop.type === undefined) {\n              prop.warnings.push(new Warning({\n                code: 'invalid-property-type',\n                message: 'Invalid type in property object.',\n                severity: Severity.WARNING,\n                sourceRange: document.sourceRangeForNode(propertyArg)!,\n                parsedDocument: document\n              }));\n            }\n            break;\n          case 'notify':\n            prop.notify = !!astValue.expressionToValue(propertyArg.value);\n            break;\n          case 'observer':\n            const val = astValue.expressionToValue(propertyArg.value);\n            prop.observerNode = propertyArg.value;\n            const parseResult = parseExpressionInJsStringLiteral(\n                document, propertyArg.value, 'identifierOnly');\n            prop.warnings.push(...parseResult.warnings);\n            prop.observerExpression = parseResult.databinding;\n            if (val === undefined) {\n              prop.observer = astValue.CANT_CONVERT;\n            } else {\n              prop.observer = JSON.stringify(val);\n            }\n            break;\n          case 'readOnly':\n            prop.readOnly = !!astValue.expressionToValue(propertyArg.value);\n            break;\n          case 'reflectToAttribute':\n            prop.reflectToAttribute =\n                !!astValue.expressionToValue(propertyArg.value);\n            break;\n          case 'computed':\n            isComputed = true;\n            const computedParseResult = parseExpressionInJsStringLiteral(\n                document, propertyArg.value, 'callExpression');\n            prop.warnings.push(...computedParseResult.warnings);\n            prop.computedExpression = computedParseResult.databinding;\n            break;\n          case 'value':\n            prop.default =\n                JSON.stringify(astValue.expressionToValue(propertyArg.value));\n            break;\n          default:\n            break;\n        }\n      }\n    }\n\n    if (isComputed) {\n      prop.readOnly = true;\n    }\n\n    // If we've already got a type, then it was found in the jsdocs, and is\n    // canonical. Otherwise we can infer it now from the attribute\n    // deserializer.\n    if (prop.type === undefined && prop.attributeType !== undefined) {\n      prop.type = prop.attributeType;\n      // Map primitive constructors to their primitive value types (e.g. String\n      // => string).\n      prop.type = esutil.CLOSURE_CONSTRUCTOR_MAP.get(prop.type) || prop.type;\n      // Assume this type is possibly null or undefined. Users should add a\n      // @type annotation if they want to tighten this type.\n      prop.type += ' | null | undefined';\n    }\n\n    if (prop.type === undefined) {\n      prop.warnings.push(new Warning({\n        code: 'no-type-for-property',\n        message: 'Unable to determine type for property.',\n        severity: Severity.WARNING,\n        sourceRange: document.sourceRangeForNode(property)!,\n        parsedDocument: document\n\n      }));\n    }\n\n    analyzedProps.push(prop);\n  }\n  return analyzedProps;\n}\n"]}